var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = void 0;
const shared = require("@volar/shared");
const featureWorkers_1 = require("../utils/featureWorkers");
const dedupe = require("../utils/dedupe");
function register(context) {
    return (uri, position) => {
        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, position, function* (position, sourceMap) {
            for (const [mappedRange] of sourceMap.getMappedRanges(position, position, data => !!data.capabilities.references)) {
                yield mappedRange.start;
            }
        }, (plugin, document, position, sourceMap, vueDocument) => __awaiter(this, void 0, void 0, function* () {
            const recursiveChecker = dedupe.createLocationSet();
            const result = [];
            yield withTeleports(document, position);
            return result;
            function withTeleports(document, position) {
                var _a;
                return __awaiter(this, void 0, void 0, function* () {
                    if (!plugin.findReferences)
                        return;
                    if (recursiveChecker.has({ uri: document.uri, range: { start: position, end: position } }))
                        return;
                    recursiveChecker.add({ uri: document.uri, range: { start: position, end: position } });
                    const references = (_a = yield plugin.findReferences(document, position)) !== null && _a !== void 0 ? _a : [];
                    for (const reference of references) {
                        let foundTeleport = false;
                        recursiveChecker.add({ uri: reference.uri, range: { start: reference.range.start, end: reference.range.start } });
                        const teleport = context.vueDocuments.teleportfromEmbeddedDocumentUri(reference.uri);
                        if (teleport) {
                            for (const [teleRange] of teleport.findTeleports(reference.range.start, reference.range.end, sideData => !!sideData.capabilities.references)) {
                                if (recursiveChecker.has({ uri: teleport.document.uri, range: { start: teleRange.start, end: teleRange.start } }))
                                    continue;
                                foundTeleport = true;
                                yield withTeleports(teleport.document, teleRange.start);
                            }
                        }
                        if (!foundTeleport) {
                            result.push(reference);
                        }
                    }
                });
            }
        }), (data, sourceMap) => data.map(reference => {
            var _a;
            const referenceSourceMap = context.vueDocuments.sourceMapFromEmbeddedDocumentUri(reference.uri);
            if (referenceSourceMap) {
                const range = (_a = referenceSourceMap.getSourceRange(reference.range.start, reference.range.end, data => !!data.capabilities.references)) === null || _a === void 0 ? void 0 : _a[0];
                if (!range)
                    return;
                reference.uri = referenceSourceMap.sourceDocument.uri;
                reference.range = range;
            }
            return reference;
        }).filter(shared.notEmpty), arr => dedupe.withLocations(arr.flat()));
    };
}
exports.register = register;
//# sourceMappingURL=references.js.map