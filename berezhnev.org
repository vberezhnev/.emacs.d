#+TITLE: Berezhnev's Emacs configuration
#+AUTHOR: Vladimir Berezhnev

#+BEGIN_SRC emacs-lisp
  ;; (server-mode)
  ;;(setq max-lisp-eval-depth 50000)
#+END_SRC

#+RESULTS:
: 50000

#+begin_src emacs-lisp :lexical no
  (if (and (fboundp 'native-comp-available-p)
         (native-comp-available-p))
    (message "Native compilation is available")
  (message "Native complation is *not* available"))
#+end_src

#+RESULTS:
: Native complation is *not* available

#+begin_src emacs-lisp :lexical no
  (if (functionp 'json-serialize)
    (message "Native JSON is available")
  (message "Native JSON is *not* available"))
#+end_src

#+RESULTS:
: Native JSON is available

* Oh-shit buttons

In case you do something and have no idea how to save yourself.

Reset variable to its default value, press ~M-:~ and run:

#+BEGIN_SRC example
(custom-reevaluate-setting 'emms-player-next-function)
#+END_SRC

Sometimes, when the whole Emacs freezes and ~C-g~ doesn't help, poke it from the
terminal with

#+BEGIN_SRC bash
kill -SIGUSR2 <pid>
#+END_SRC

It should get Emacs unstuck. For easier debugging it might be enough to
~M-x toggle-debug-on-quit~ and then hit ~C-g~ to pop up a ~*Backtrace*~ buffer.

Also, it may be useful to see all processes running within Emacs. Try ~M-x
list-processes~. To kill a process, run

#+BEGIN_EXAMPLE emacs-lisp
(kill-process "process-name")
#+END_EXAMPLE

* Facts

Similar to ~ansible_facts~, we are going to inspect the system that we are
currently running, so we can adjust our Emacs configuration
appropriately. Namely we want to differentiate between operating systems
(GNU/Linux, Windows, Android) and also purpose of the OS. We want the most
complete Emacs configuration only on a proper workspace. Everywhere else just a
compact setup that doesn't require any system dependencies.

The ~android-p~ predicate is based on an environment variable that is defined
defined at least in Termux. The ~workstation-p~ predicate is based on system
hostname.

#+BEGIN_SRC emacs-lisp
(setq gui-p         (display-graphic-p)
      cli-p         (not gui-p)
      android-p     (getenv "ANDROID_ROOT")
      linux-p       (and (eq system-type 'gnu/linux) (not android-p))
      windows-p     (eq system-type 'windows-nt)
      workstation-p (member (system-name)
                            '("berezhnev")))
#+END_SRC

* Defaults

For whatever reason, Emacs modifies hand-written ~init.el~ and puts random
customizations in there. Git tracks them and throws them at us. I do not care
about them! Emacs, please write customizations to a separate file that I can put
into ~.gitignore~.

#+BEGIN_SRC emacs-lisp
(setq custom-file (concat user-emacs-directory "custom.el"))
(if (file-exists-p custom-file)
    (load custom-file))
#+END_SRC


#+BEGIN_SRC emacs-lisp
  ;; https://www.emacswiki.org/emacs/AutoPairs
  ;; TODO try https://github.com/Fuco1/smartparens instead
  (electric-pair-mode)


  ;; Middle-click paste where cursor is, don't care about mouse position
  ;; https://superuser.com/questions/330849/can-i-tell-emacs-to-paste-middle-mouse-button-on-the-cursor-position
  (setq mouse-yank-at-point t)


  ;; Automatically reload changed files
  ;; https://stackoverflow.com/q/1480572/3285282
  (global-auto-revert-mode t)


  ;; keyboard scroll one line at a time
  ;; scroll when cursor is five lines from the edge
  ;; and don't ever recenter the cursor when scrolling
  (setq scroll-step 1)
  (setq scroll-margin 5)
  (setq scroll-conservatively 101)


  ;; Don't throw "Invalid coding system" errors on me when writting a file
  (define-coding-system-alias 'UTF-8 'utf-8)


  ;; Don't mess CWD with #foo.py# and foo.py~ files
  ;; https://emacs.stackexchange.com/a/34
  ;; (setq backup-directory-alist '(("." . "~/MyEmacsBackups")))
  ;; (setq backup-directory-alist '("~/MyEmacsBackups"))
  ;; (setq backup-directory-alist `(("." . "~/MyEmacsBackups")))


  ;; https://stackoverflow.com/a/18330742/3285282
  (setq backup-by-copying t               ; don't clobber symlinks
        version-control t                 ; version numbers for backup files
        delete-old-versions t             ; delete excess backup files silently
        delete-by-moving-to-trash t
        kept-old-versions 6               ; oldest versions to keep when a new numbered backup is made (default: 2)
        kept-new-versions 9               ; newest versions to keep when a new numbered backup is made (default: 2)
        auto-save-default t               ; auto-save every buffer that visits a file
        display-line-numbers 'relative
        )
#+END_SRC

#+RESULTS:
: relative

#+BEGIN_SRC emacs-lisp
  (use-package display-line-numbers
    :ensure nil
    :hook ((prog-mode . display-line-numbers-mode))
    :config
    (setq display-line-numbers 'relative)
    (setq display-line-numbers-width 3))

  (save-place-mode 1)
#+END_SRC

#+RESULTS:
: t

Let's have some funny message on the top of the ~*scratch*~ buffer.

#+BEGIN_SRC emacs-lisp
(setq initial-scratch-message ";; Do you even lisp, bro? ಠ_ಠ\n\n\n")
#+END_SRC


We don't want to quit emacs. Ever! Sometimes it happens to me, that I
accidentally type ~:wq~ because I want to close the current buffer but don't
realize that I am not in any split, so this is my last visible buffer. In such
case, Emacs gets killed and it sucks so bad (because I have ten eyebrowse
workspaces full of things, they are just not currently visible). So, let's take
this safety measure and ask everytime before quiting.

#+BEGIN_SRC emacs-lisp
  ;; (setq confirm-kill-emacs 'y-or-n-p)
  (defalias 'yes-or-no-p 'y-or-n-p)
  (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
  (toggle-frame-fullscreen)
#+END_SRC

#+RESULTS:

#+begin_src emacs-lisp :lexical no
  (xterm-mouse-mode t)
#+end_src

#+RESULTS:
: t

** Keep folders clean

Watch this great explanation about Emacs temporary files such as backups,
autosaves, etc: https://www.youtube.com/watch?v=XZjyJG-sFZI

The show notes can be found here
https://github.com/daviwil/emacs-from-scratch/blob/master/show-notes/Emacs-Tips-Cleaning.org

Don't clutter project directories with backup files,
e.g. ~Emacs.org\~~.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist
      `(("." . ,(expand-file-name "tmp/backups/" user-emacs-directory))))
#+END_SRC

Don't clutter project directories with autosave files,
e.g. ~#Emacs.org#~.

#+BEGIN_SRC emacs-lisp
;; auto-save-mode doesn't create the path automatically!
(make-directory (expand-file-name "tmp/auto-saves/" user-emacs-directory) t)

(setq auto-save-list-file-prefix
      (expand-file-name "tmp/auto-saves/sessions/" user-emacs-directory))

(setq auto-save-file-name-transforms
      `((".*" ,(expand-file-name "tmp/auto-saves/" user-emacs-directory) t)))
#+END_SRC

Don't clutter project directories with random garbage generated by Emacs
packages.

#+BEGIN_SRC emacs-lisp
(use-package no-littering
  :ensure t)
#+END_SRC

Don't clutter project directories with undo tree files,
e.g. ~.README.\~undo-tree\~~

#+BEGIN_SRC emacs-lisp
(setq undo-tree-history-directory-alist '(("." . "~/.emacs.d/undo")))
#+END_SRC

* Daemon mode

See this great blogpost about running multiple Emacs daemons using systemd
https://tychoish.com/post/running-emacs/

See https://www.youtube.com/watch?v=ZjCRxAMPdNc
See https://github.com/daviwil/emacs-from-scratch/blob/d24357b488862223fecaebdad758b136b0ca96e7/show-notes/Emacs-Tips-08.org

The biggest blocker for me to switch to daemon mode is that Eyebrowse doesn't
support sharing workspaces accross all frames (i.e. closing an emacsclient will
destroy all its workspaces)

* Package management
** Automatical updates

We want to automatically update Emacs packages in order to avoid annoying warnings
during startup, that some package is recommended to be updated.

Update automatically every night, don't ask for confirmation and don't bother us
with update at Emacs startup.

See https://emacs.stackexchange.com/a/31904

#+BEGIN_SRC emacs-lisp
(use-package auto-package-update
   :ensure t
   :config
   (setq auto-package-update-delete-old-versions t
         auto-package-update-interval 365
         auto-package-update-prompt-before-update nil
         auto-package-update-hide-results t)
   (auto-package-update-at-time "04:00"))
#+END_SRC

Unfortunatelly updating takes around two minutes which is long enough to get
disconnected from IRC, which is super annoying. As a temporary workaround let's
update only once a year. We are waiting for async updates.

See https://github.com/rranelli/auto-package-update.el/issues/39

When the update is failing, it starts to ask whether to kill the buffers
or what. Don't do that.

See https://emacs.stackexchange.com/q/14509

#+BEGIN_SRC emacs-lisp
(setq kill-buffer-query-functions nil)
#+END_SRC

Some packages won't properly reload their configuration after update and break.
We need to take care of that.

#+BEGIN_SRC emacs-lisp
(add-hook 'auto-package-update-after-hook
          (lambda ()
            (load-library "yasnippet-snippets.el")))
#+END_SRC

** Quelpa

Quelpa is a package management tool to compile and install Emacs Lisp packages
directly from upstream (i.e from git repository hosted for example on Git Hub),
in opposite to installing them from ELPA or MELPA.

#+BEGIN_SRC emacs-lisp
(use-package quelpa
  :ensure t)
#+END_SRC

By default, Quelpa is called by its own ~quelpa~ function, which is /meh/. Let's
use use integration with ~use-package~.

#+BEGIN_SRC emacs-lisp
(use-package quelpa-use-package
  :ensure t)
#+END_SRC

We often want to use Quelpa for our own patched versions of packages that are
otherwise available and previously installed from MELPA.

#+BEGIN_SRC emacs-lisp
;; (setq quelpa-upgrade-p t)
#+END_SRC

** System packages

Some third-party Emacs packages are built around or internally use
system packages or executables. We can install them from within the
Emacs configuration.

See https://gitlab.com/jabranham/system-packages

#+BEGIN_SRC emacs-lisp
  (use-package system-packages
    :ensure t)
#+END_SRC

I don't want to guess my package manager because running this
configuration on a different system could lead to inconsistencies or
failures because of different package names. Instead, let's define
helper functions for each package manager that we care about and
specify packages for each package manager explicitly.

#+BEGIN_SRC emacs-lisp
    (defun frostyx/guix (&key install)
      (let ((system-packages-package-manager 'guix)
            (system-packages-use-sudo nil))
        (or (frostyx/rpm-query install)
     	  (system-packages-install install))))
#+END_SRC

#+RESULTS:
: frostyx/guix

We need to use ~system-packages-install~ instead of
~system-packages-ensure~ to avoid asking for sudo password even though
the packages are already installed.

#+BEGIN_SRC emacs-lisp
(defun frostyx/rpm-query (pack)
  (equal 0 (shell-command
            (concat "rpm -q " pack))))
#+END_SRC

Just in case, set the package manager defaults to something expected

#+BEGIN_SRC emacs-lisp
(setq system-packages-package-manager 'guix)
(setq system-packages-use-sudo t)
#+END_SRC

* Secrets

Please do not hardcode your passwords or secret information into source code.
Store them into some keyring application (e.g. ~pass~) and query them instead.
This solution provides many advantages:

1. You can safely share your configs publicly without exposing sensitive data,
   /*duh*/
2. No messing with partially commiting files just to leave the sensitive parts
3. In comparison to including a git ignored file with password definitions,
   keyrings have strong encryption

See:
- https://www.passwordstore.org/
- https://medium.com/@chasinglogic/the-definitive-guide-to-password-store-c337a8f023a1

#+BEGIN_SRC emacs-lisp
(use-package password-store
  :ensure t)
#+END_SRC

* Async
** ob-async
Allows complete code in async mode. Now you don't need to wait the execution

Require the package and ~ob-async~ will handle any source block which includes ~:async~ in its header-args.

#+begin_src emacs-lisp :lexical no
  (use-package ob-async
  	:ensure t)
#+end_src

#+RESULTS:

* Key bindings

You might be interested in Emacs key binding conventions.
Please read the "Demystifying Emacs bindings" section here
https://yiufung.net/post/emacs-key-binding-conventions-and-why-you-should-try-it/

Or the official documentation
https://www.gnu.org/software/emacs/manual/html_node/elisp/Key-Binding-Conventions.html

As per usual, we have half a dozen ways to do something in Emacs, in this case
customizing key bindings. There is ~global-set-key~ for global key definitions,
~define-key~ for mode-specific definitions (or global definitions as well, when
using ~global-map~), ~evil-define-key~ for Vim users, and many more than I am
not aware of. For unbinding keys, we have ~global-unset-key~ or binding
something to ~nil~. Brace yourselves, we are going to introduce even more
options.

General seems to be the most convinient and consitent way manage key bindings
for both octopuses and Evil users.

See https://github.com/noctuid/general.el

#+BEGIN_SRC emacs-lisp
(use-package general
  :ensure t)
#+END_SRC

Provide Vim-like definers such as ~general-nmap~, ~general-imap~,
~general-vmap~, etc.

See https://github.com/noctuid/general.el#vim-like-definers

#+BEGIN_SRC emacs-lisp
  (general-evil-setup)

  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC

#+RESULTS:
: ibuffer

#+begin_src emacs-lisp :lexical no
  (use-package all-the-icons-ibuffer
  	:ensure t
  	:config
  																				; Predicate whether the icons are able to be displayed."
  	(setq all-the-icons-ibuffer-display-predicate #'display-graphic-p)

  	;; Whether display the icons.
  	(setq all-the-icons-ibuffer-icon t)

  	;; Whether display the colorful icons.
  	;; It respects `all-the-icons-color-icons'.
  	(setq all-the-icons-ibuffer-color-icon t)

  	;; The default icon size in ibuffer.
  	(setq all-the-icons-ibuffer-icon-size 1.0)

  	;; The default vertical adjustment of the icon in ibuffer.
  	(setq all-the-icons-ibuffer-icon-v-adjust 0.0)

  	;; Use human readable file size in ibuffer.
  	(setq  all-the-icons-ibuffer-human-readable-size t)

  	;; A list of ways to display buffer lines with `all-the-icons'.
  	;; See `ibuffer-formats' for details.
  	all-the-icons-ibuffer-formats

  	;; Slow Rendering
  	;; If you experience a slow down in performance when rendering multiple icons simultaneously,
  	;; you can try setting the following variable
  	(setq inhibit-compacting-font-caches t)

  	(add-hook 'ibuffer-mode-hook 'all-the-icons-ibuffer-mode))
#+end_src

#+RESULTS:
: t

Be consistent and map key bindings like this

#+BEGIN_EXAMPLE emacs-lisp
(general-nmap "KEY" 'command)
#+END_EXAMPLE

Or for a specific mode

#+BEGIN_EXAMPLE emacs-lisp
(general-nmap
  :keymaps 'some-mode-map
  "KEY" 'command)
#+END_EXAMPLE

And unbind key bindings like this (you can ommit the mode map)

#+BEGIN_EXAMPLE emacs-lisp
(general-unbind 'normal some-mode-map "KEY")
#+END_EXAMPLE

* Mouse

Smoother mouse scroll

#+begin_src emacs-lisp :lexical no
  (use-package ultra-scroll
    :quelpa (ultra-scroll
            :fetcher github
            :repo "jdtsmith/ultra-scroll"
            :branch "main")
    :init
    (setq scroll-conservatively 101 ; important!
          scroll-margin 0) 
    :config
    (ultra-scroll-mode 1))
#+end_src

#+RESULTS:
: t

#+BEGIN_SRC emacs-lisp
;; (pixel-scroll-precision-mode)
#+END_SRC

Moving a hand to press mouse middle-click for every paste operation is
such a waste of time.

#+BEGIN_SRC emacs-lisp
(general-define-key
 :states '(emacs normal insert motion)
 "C-y" 'mouse-yank-primary)
#+END_SRC

I want mouse double-click to behave and select exactly the same range
of words as in a terminal emulator like alacritty.

See https://superuser.com/a/901624

TODO Create a MELPA package for this (called e.g. ~double-click~,
~terminal-like-double-click~).

#+BEGIN_SRC emacs-lisp
(defun get-word-boundary ()
  "Return the boundary of the current word.
 The return value is of the form: (cons pos1 pos2)."
  (let ((chars  "-A-Za-z0-9_.@/"))
    (save-excursion
      (let (p1 p2)
        (progn
          (skip-chars-backward chars)
          (setq p1 (point))
          (skip-chars-forward chars)
          (setq p2 (point)))
        (cons p1 p2)))))

(defun select-word ()
  "Mark the url under cursor."
  (interactive)
  (let (bds)
    (setq bds (get-word-boundary))
    (set-mark (car bds))
    (goto-char (cdr bds))))

(global-set-key [double-mouse-1] 'select-word)
#+END_SRC

* Living in Evil

@TODO link the great blog post explaining emacs key bindings

TODO rant about Emacs key bindings

TODO xkcd image mocking Emacs keybindings

See https://github.com/noctuid/evil-guide


These two needs to be set before we even try to load Evil (or ~evil-collection~ or
~evil-leader~).

See
- https://github.com/emacs-evil/evil-collection#installation
- https://github.com/emacs-evil/evil-collection/issues/215

#+BEGIN_SRC emacs-lisp
(setq evil-want-keybinding nil)
(setq evil-want-integration t)
#+END_SRC

** Evil leader
A common way to define custom key bindings for Vim ~NORMAL~ mode is by utilizing
so called ~<leader>~ key. By default it is mapped to ~\~ but can be remaped to
something else (in my case to comma). Custom mappings are then defined a sequence
of ~<leader>~ key followed by one or more letters. An example can be ~\ga~ for
~git add~ and ~\gc~ for ~git commit~.

For Emacs, this functionality is implemented in ~evil-leader~ package.

See https://github.com/cofi/evil-leader


According to documentation we need to enable ~evil-leader-mode~ before ~evil-mode~.

#+BEGIN_QUOTE
Note: You should enable global-evil-leader-mode before you enable evil-mode,
otherwise evil-leader won’t be enabled in initial buffers (*scratch*, *Messages*, …).
#+END_QUOTE

I don't know about these, but more importantly ~evil-leader~ needs to go first,
otherwise it doesn't work in ~org-mode~.

#+BEGIN_SRC emacs-lisp
  (use-package evil-leader
    :ensure t
    :config
    (evil-leader/set-leader "SPC")
    (global-evil-leader-mode))
#+END_SRC

#+RESULTS:
: t

I am thinking about replacing my Hydra setup with General leader keys,
see ~devel/frostyx-future.el~.

** Evil Mode

See:
- https://github.com/emacs-evil/evil
- https://www.reddit.com/r/emacs/comments/726p7i/evil_mode_and_use_package/dnh3338?utm_source=share&utm_medium=web2x

#+BEGIN_SRC emacs-lisp
  (use-package evil
    :ensure t ;; install the evil package if not installed
    :init ;; tweak evil's configuration before loading it
    (evil-select-search-module 'evil-search-module 'evil-search)
    (setq evil-ex-complete-emacs-commands nil)
    ;; (setq evil-vsplit-window-right t)
    ;; (setq evil-split-window-below t)
    ;;(setq evil-shift-round nil)
    (setq evil-want-C-u-scroll t)
    (setq evil-want-C-i-jump nil)

    (setq evil-ex-set-initial-state 'normal)

    :config ;; tweak evil after loading it
    (evil-mode))
#+END_SRC

#+RESULTS:
: t

Let's unbind arrow keys for movement. I exclusively use ~hjkl~, so the arrow
keys for movement are useless. On the other hand, they might come handy for
other applications such as IRC client to show previous messages in the prompt or
for terminal application to show previous commands.

#+BEGIN_SRC emacs-lisp
(eval-after-load "evil-maps"
  (dolist (map '(evil-motion-state-map
                 evil-insert-state-map
                 evil-emacs-state-map))
    (define-key (eval map) (kbd "<up>") nil)
    (define-key (eval map) (kbd "<down>") nil)
    (define-key (eval map) (kbd "<left>") nil)
    (define-key (eval map) (kbd "<right>") nil)))
#+END_SRC

@TODO this ^^ requires restarting ~evil-mode~ to have an effect

We seem to need to set how undo/redo should work, otherwise it doesn't work.
https://github.com/syl20bnr/spacemacs/issues/14036#issuecomment-707072523

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :config
  (global-undo-tree-mode)
  (evil-set-undo-system 'undo-tree))
#+END_SRC

Change shape of cursor in TTY mode.
https://github.com/7696122/evil-terminal-cursor-changer

#+begin_src emacs-lisp :lexical no
  (use-package evil-terminal-cursor-changer
  	:ensure t
  	:config
  	(unless (display-graphic-p)
            (require 'evil-terminal-cursor-changer)
            (evil-terminal-cursor-changer-activate))
  	 (setq evil-motion-state-cursor 'box)  ; █
       (setq evil-visual-state-cursor 'box)  ; █
       (setq evil-normal-state-cursor 'box)  ; █
       (setq evil-insert-state-cursor 'bar)  ; ⎸
       (setq evil-emacs-state-cursor  'hbar)) ; _
#+end_src

#+RESULTS:
: t

** Evil packages

Thanks to ~evil-surround~ it is easy to change the surroundings of the current
text object. Most commonly, this can be used for:

1. Changing quotes - Doing ~cs'"~ in ~'Hello world'~ changes single quotes to
   double quotes
2. Changing tags - TODO visual mode

See https://github.com/emacs-evil/evil-surround

#+BEGIN_SRC emacs-lisp
(use-package evil-surround
  :ensure t
  :config
  (global-evil-surround-mode))
#+END_SRC

TODO evil-indent-textobject

#+BEGIN_SRC emacs-lisp
;; ;; @FIXME missing config
;; (use-package evil-indent-textobject
;;   :ensure t)
#+END_SRC

TODO

See https://github.com/redguardtoo/evil-matchit

#+BEGIN_SRC emacs-lisp
(use-package evil-matchit
  :ensure t
  :config
  (global-evil-matchit-mode))
#+END_SRC

When programming, it is usefull to comment-out pieces of a code to temporarily disable them.
This is valuable when refactoring something and deciding what implementation to use, when
temporarily adding and then enabling/disabling breakpoints, etc. I do it thousand times a day.
Instead of removing the lines and then undoing back, or maybe weirdly commenting the code
line by line, use ~evil-commentary~.

See https://github.com/linktohack/evil-commentary

The usage is straightforward. In ~NORMAL~ mode press ~gcc~ to comment the current line of code.
If it is already commented, it will uncomment it. This behavior is same for all the following
commands. To comment e.g. next 3 lines, use ~3gcc~. To comment a ~VISUAL~ selection, press
~gc~. Another useful option is to do ~gy~ which comments the selection but yanks it first.

#+BEGIN_SRC emacs-lisp
(use-package evil-commentary
  :ensure t
  :config
  (evil-commentary-mode))
#+END_SRC

There is no ~:set~ command in Evil. I wrote my own package for this.

See https://github.com/FrostyX/evil-set-option
See http://frostyx.cz/posts/emacs-evil-set-option

#+BEGIN_SRC emacs-lisp
(use-package evil-set-option
  :ensure t
  :quelpa (evil-set-option
           :fetcher github
           :repo "FrostyX/evil-set-option"
           :branch "main")
  :config
  (evil-set-option-mode))
#+END_SRC

** Vim keybindings everywhere

#+BEGIN_SRC emacs-lisp
(use-package evil-collection
  :ensure t
  :after evil
  :config
  (evil-set-initial-state 'ibuffer-mode 'normal)
  (evil-set-initial-state 'bookmark-bmenu-mode 'normal)
  (evil-set-initial-state 'vterm-mode 'normal)
  (evil-set-initial-state 'org-timeblock-mode 'emacs)
  (evil-set-initial-state 'org-agenda-mode 'emacs)
  (evil-set-initial-state 'org-super-agenda-mode 'emacs)
  (evil-set-initial-state 'calibredb-mode 'normal)
  (evil-set-initial-state 'enlight-mode 'emacs)
  (evil-set-initial-state 'org-timeblock-mode 'emacs)
  (evil-set-initial-state 'org-timeblock-list-mode 'emacs)
  ;; (evil-set-initial-state 'dired-mode 'emacs)
  (evil-set-initial-state 'treemacs-mode 'emacs)
  (evil-set-initial-state 'xwidget-webkit-mode 'emacs)
  (evil-set-initial-state 'sunrise-mode 'emacs)
  (evil-collection-init))

;; use evil mode in the buffer created from calling `M-x list-packages'.
;; https://blog.aaronbieber.com/2016/01/23/living-in-evil.html#adding-hjkl-bindings-
(evil-add-hjkl-bindings occur-mode-map 'emacs
  (kbd "/")       'evil-ex-search-forward
  (kbd "n")       'evil-search-next
  (kbd "N")       'evil-search-previous
  (kbd "C-d")     'evil-scroll-down
  (kbd "C-u")     'evil-scroll-up
  (kbd "C-w C-w") 'other-window)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC example
(setq evil-default-state 'normal) ;; changes default state to emacs
#+END_SRC

TODO ctrl+w hjkl is too slow

#+BEGIN_SRC example
(general-define-key
 :states '(normal insert motion)
 "C-h" 'evil-window-left
 "C-j" 'evil-window-down
 "C-k" 'evil-window-up
 "C-l" 'evil-window-right)
#+END_SRC

I hate that ~keyboard-escape-quit~ breaks the current window configuration and
leaves only one window opened. As an Evil user, I press ~ESC~ thousands of times
a day and sometimes it hapens that I press ~ESC ESC ESC~ and call that
function. It's a prefix key, so it cannot be unbound the standard way.

See https://emacs.stackexchange.com/questions/14755/how-to-remove-bindings-to-the-esc-prefix-key

#+BEGIN_SRC example
;; (define-key key-translation-map (kbd "ESC") (kbd "C-g"))
(global-unset-key (kbd "ESC ESC ESC"))
#+END_SRC

TODO package manager key bindings, these needs to go somewhere else

See https://www.reddit.com/r/emacs/comments/7dsm0j/how_to_get_evilmode_hjkl_to_work_inside_mx/

#+BEGIN_SRC example
(evil-define-key 'normal package-menu-mode-map (kbd "m") #'package-menu-mark-install)
(evil-define-key 'normal package-menu-mode-map (kbd "u") #'package-menu-mark-unmark)
(evil-define-key 'normal package-menu-mode-map (kbd "x") #'package-menu-execute)
#+END_SRC

** More Vim compatibility

#+BEGIN_SRC example
;; https://emacsredux.com/blog/2014/08/27/a-peek-at-emacs-24-dot-4-superword-mode/
;; #@FIXME using this manually in a python file works, but this config setting not
;; Probably `global-*' mode settings will be required here. Wihout global, the setting
;; is only for the current buffer
;; (superword-mode)
(global-superword-mode)


;; https://emacs.stackexchange.com/a/9584
;; Superword mode seems to apply only on searching, adding also this,
;; to get w, yiw, dw, etc working as expected
(modify-syntax-entry ?_ "w")

;; https://github.com/syl20bnr/spacemacs/blob/develop/doc/FAQ.org#include-underscores-in-word-motions
;; (add-hook 'prog-mode-hook #'(lambda () (modify-syntax-entry ?_ "w")))
;; (add-hook 'mhtml-mode-hook #'(lambda () (modify-syntax-entry ?_ "w")))

;; https://emacs.stackexchange.com/questions/9583/how-to-treat-underscore-as-part-of-the-word/20717#20717
;; (with-eval-after-load 'evil
;;     (defalias #'forward-evil-word #'forward-evil-symbol)
;;     ;; make evil-search-word look for symbol rather than word boundaries
;;     (setq-default evil-symbol-word-search t))
#+END_SRC


See https://www.reddit.com/r/emacs/comments/86iq3w/evil_cw_o_toggle_windows/

#+BEGIN_SRC example
(defun toggle-fullscreen ()
  (interactive)
  (if (window-parent)
      (delete-other-windows)
    (winner-undo)))
;;(define-key evil-normal-state-map (kbd "C-w o") 'toggle-fullscreen)
(define-key evil-normal-state-map (kbd "C-w o") 'toggle-frame-fullscreen)
#+END_SRC

Incrementing and decrementing numbers
https://github.com/cofi/evil-numbers

#+BEGIN_SRC example
(use-package evil-numbers
  :ensure t)
#+END_SRC

Decrementing is done via ~C-x~ in Vim, which is an important keybind
in Emacs. We will only bind incrementing.

#+BEGIN_SRC example
(general-nmap "C-a" 'evil-numbers/inc-at-pt)
#+END_SRC

** Custom Evil keybindings

Emacs provides so many ways to create custom keybindings and to run commands in
general (e.g. emacs key-chords, helm, hydra, evil-leader, etc). You will probably
find multiple shortcuts in this document for executing a same command. One of them
will them will be compatible with my Vim cofiguration which has been wired to my
brain from a decade of using it. The other shortcuts will be more Emacsy.

TODO The question is - should we define them here or within their use-package definitions?

TODO projectile

#+BEGIN_SRC example
(evil-leader/set-key
  "f" 'projectile-find-file
  "p" 'projectile-switch-project
  "s" 'helm-lsp-workspace-symbol)
#+END_SRC

Sometimes it happens that ~helm-projectile~ or ~helm-projectile-find-file~
suddenly stops working for a project and nothing (including Emacs restart)
helps. The only solution I accidentally found is running ~helm-ls-git-ls~
command, close it, and then finding files works again.

See https://github.com/emacs-helm/helm-ls-git

TODO magit

#+begin_src emacs-lisp :lexical no
  (use-package magit
  	:ensure t)
#+end_src

#+RESULTS:

#+BEGIN_SRC emacs-lisp
(evil-leader/set-key
  "ga" 'magit-stage-file
  "gc" 'magit-commit  ;; Maybe magit-commit-create
  "gp" 'magit-push-current) ;; @TODO still asks for something, use more specific function
#+END_SRC

#+RESULTS:

Random garbage

#+BEGIN_SRC emacs-lisp
(evil-leader/set-key
  "w" 'evil-window-vsplit)
  ;;"def" 'evil-jump-to-tag)
#+END_SRC

#+RESULTS:

These are not exactly Vim based but I don't want to start a separate
section. These are a life-saver for non-Evil buffers.

#+BEGIN_SRC emacs-lisp
(general-define-key
 :states '(normal visual insert emacs motion)
 "C-x l" 'evil-switch-to-windows-last-buffer
 "C-x SPC" 'hydra-main/body
 "C-x ;"  'my/smart-buffers-list
 "C-x , ;" 'consult-buffer)
#+END_SRC

** Custom Evil commands

Evil even allows you to create your own colon commands. I don't need it, most folks
probably don't need it, but you got to admit it's pretty spectacular.

See https://emacs.stackexchange.com/questions/10350/how-can-i-add-a-new-colon-command-to-evil

This command is mainly an example how to do it. I have probably never used it.

#+BEGIN_SRC example
(eval-after-load 'evil-ex
  '(evil-ex-define-cmd "Gbrowse" 'browse-at-remote))
#+END_SRC

I very much liked the ~:retab~ command, which is missing in Evil.
See https://github.com/emacs-evil/evil/pull/1846

#+BEGIN_SRC example
(evil-define-command evil-retab (tabstop)
  "Convert all tabs to spaces or the other way around.
Replace all sequences of white-space containing a <Tab> with new
strings of white-space using the new TABSTOP value given.
If you do not specify a new TABSTOP size or it is zero, Evil uses the
current value of `tab-width'."
  (interactive "<a>")
  (let ((beg (if (use-region-p) (region-beginning) (point-min)))
        (end (if (use-region-p) (region-end) (point-max)))
        (retab (if indent-tabs-mode #'tabify #'untabify))
        (tab-width (cond ((not tabstop) tab-width)
                         ((equal tabstop "0") tab-width)
                         (t (string-to-number tabstop)))))
    (funcall retab beg end)))

(evil-ex-define-cmd "ret[ab]" 'evil-retab)
#+END_SRC

* Colorscheme
** Themes

Let's install all the interesting themes.

See http://chriskempson.com/projects/base16/

#+BEGIN_SRC emacs-lisp
    (use-package base16-theme
      :ensure t)

    (use-package seoul256-theme
      :ensure t
      :disabled t)

    (use-package gruvbox-theme
      :ensure t
      :disabled t)

    (use-package doom-themes
      :if window-system
      :ensure t
      :defer nil
      :config
      (setq doom-themes-enable-bold t
            doom-themes-enable-italic t)
      (doom-themes-visual-bell-config) ; Enable flashing mode-line on errors
      (if (display-graphic-p)
          (progn
            (setq doom-themes-treemacs-theme "doom-colors") ; use the colorful treemacs theme
            (doom-themes-treemacs-config)))
      ;; Corrects (and improves) org-mode's native fontification.
      (doom-themes-org-config))
#+END_SRC

#+RESULTS:
: t

At this point, my whole desktop environment uses ~base16-chalk~

#+BEGIN_SRC emacs-lisp
(if workstation-p
   (load-theme 'base16-chalk t))
#+END_SRC

** Theme changer
#+BEGIN_SRC emacs-lisp
  (use-package theme-changer
    :ensure nil
    :demand nil
    :straight (:host github :repo "hadronzoo/theme-changer" :branch "master")
    :config
    (setq calendar-location-name "Vladivostok, RU")
    (setq calendar-latitude 43.11)
    (setq calendar-longitude 131.88))

  ;;(change-theme 'tsdh-light 'doom-xcode)
  ;;(change-theme 'doom-one-light 'doom-outrun-electric)
  (load-theme 'doom-one-light)
#+END_SRC

#+RESULTS:
: [nil 26501 38645 0 nil change-theme (tsdh-light doom-xcode doom-xcode) nil 0 nil]

** Auto dark
#+BEGIN_SRC emacs-lisp
(use-package auto-dark
  :ensure t
  :config
  (setq auto-dark-dark-theme 'doom-xcode)
  (setq auto-dark-light-theme 'doom-one-light) ;; tsdh-light
  (setq auto-dark-polling-interval-seconds 0)
  (setq auto-dark-allow-osascript nil)
  (setq auto-dark-allow-powershell nil)
  (auto-dark-mode t))
#+END_SRC

#+RESULTS:
: t

** Blur
#+BEGIN_SRC emacs-lisp
  ;; (set-frame-parameter (selected-frame) 'alpha-background 70)
  ;; (add-to-list 'default-frame-alist '(alpha-background . 70))

  (set-frame-parameter (selected-frame) 'alpha '(98 . 98))
  (add-to-list 'default-frame-alist '(alpha . (98 . 98)))
#+END_SRC

#+RESULTS:
: ((alpha-background . 70) (font . Iosevka 12) (ns-transparent-titlebar . t) (horizontal-scroll-bars) (alpha 98 . 98) (vertical-scroll-bars))

** Colors

Let's define our set of colors based on current theme, so we can easily use them
for customizing third-party packages.

See http://chriskempson.com/projects/base16/#styling-guidelines

#+BEGIN_SRC emacs-lisp
(if workstation-p
    (setq my/black (plist-get base16-chalk-theme-colors :base00)
          my/gray "thistle" ;;(plist-get base16-chalk-theme-colors :base01)
          my/lgray (plist-get base16-chalk-theme-colors :base03)
          ;; ... grayish colors from base02 to base06
          my/white (plist-get base16-chalk-theme-colors :base07)
          my/red (plist-get base16-chalk-theme-colors :base08)
          my/orange (plist-get base16-chalk-theme-colors :base09)
          my/yellow (plist-get base16-chalk-theme-colors :base0A)
          my/green (plist-get base16-chalk-theme-colors :base0B)
          my/lblue (plist-get base16-chalk-theme-colors :base0C)
          my/blue (plist-get base16-chalk-theme-colors :base0D)
          my/purple (plist-get base16-chalk-theme-colors :base0E)
          my/brown (plist-get base16-chalk-theme-colors :base0F)))
#+END_SRC

#+RESULTS:

The custom theme and its colors looks great on my workstation but it won't be
ideal on various systems and devices. Let's define a fallback set of colors
based on the default Emacs theme.

#+BEGIN_SRC emacs-lisp
(if (not workstation-p)
    (setq my/black "black"
          my/gray  "light cyan"
          my/lgray "gray60"
          my/white "white"
          my/red "Firebrick"
          my/orange "orange red"
          my/yellow "lightyellow"
          my/green "ForestGreen"
          my/lblue "midnight blue"
          my/blue "blue"
          my/purple "Purple"
          my/brown "brown"))
#+END_SRC

#+RESULTS:
: brown

* Window management
** ibuffer-vc
#+begin_src emacs-lisp :lexical no
  (use-package ibuffer-vc
  	:ensure t)
#+end_src

#+RESULTS:

#+begin_src emacs-lisp :lexical no
  (defun my/center (width)
    (interactive "nBuffer width: ")
    (let* ((adj          (- (window-text-width)
                            width))
           (total-margin (+ adj
                            left-margin-width
                            right-margin-width)))
      (setq left-margin-width  (/ total-margin 2))
      (setq right-margin-width (- total-margin left-margin-width)))
    (set-window-buffer (selected-window) (current-buffer)))
#+end_src

#+RESULTS:
: my/center

** Window rules

Emacs default window management makes me want to kill myself. After six months,
I still have absolutely no idea how it works. New windows literaly appear on the
least expected positions, they randomly change, some of them even break the
current split configuration. It seems like the internal window manager is trying
so hard to be smart but for me, it has the exactly opposite effect.

Meanwhile, this magic is not necessary (let alone useful) at all. Maybe it is
for vanilla Emacs but in Evil world, the splits and window management is
just amazing.

Let's just open everything in the current window, shall we? I can split manually
if I want to.

#+BEGIN_SRC example
(use-package current-window-only
  :quelpa (current-window-only
           :fetcher github
           :repo "FrostyX/current-window-only")
  :config
  (current-window-only-mode))
#+END_SRC

Update: Two years in, mainly thanks to
https://www.masteringemacs.org/article/demystifying-emacs-window-manager
I now understand the basic concepts of the default Emacs window
manager but I still hate it. Continuing to use ~current-window-only~
till the end of times.

** Xclip
#+begin_src emacs-lisp :lexical no
  (use-package xclip
    :ensure t
    :config
    (xclip-mode 1))
#+end_src

#+RESULTS:

* Applications

If I shoot myself into my leg and accidentally break a buffer by running an
application in it and panicking how to get back, just kill the buffer with
~M-x kill-buffer~.

** Gitignore

Downloading .gitignore files manually from GitHub is just fine but there is a
cool package for that.

https://github.com/xuchunyang/gitignore-templates.el

#+BEGIN_SRC emacs-lisp
(use-package gitignore-templates
  :ensure t)
#+END_SRC

I don't want any other source than GitHub's gitignore repository
https://github.com/github/gitignore

#+BEGIN_SRC emacs-lisp
(setq gitignore-templates-api 'github)
#+END_SRC

** PDF tools
#+begin_src emacs-lisp :lexical no
  (use-package pdf-tools
    :ensure t
    :defer t
    :mode (("\\.pdf\\'" . pdf-view-mode))
    :config
    ;; (add-hook 'pdf-tools-enabled-hook 'pdf-view-midnight-minor-mode)
    (use-package saveplace-pdf-view  )
    (save-place-mode 1)
    (setq-default pdf-view-display-size 'fit-page)
    (pdf-tools-install)
    :bind (:map pdf-view-mode-map
                ("\\" . hydra-pdftools/body)
                ("<s-spc>" .  pdf-view-scroll-down-or-next-page)
                ("g"  . pdf-view-first-page)
                ("G"  . pdf-view-last-page)
                ("l"  . image-forward-hscroll)
                ("h"  . image-backward-hscroll)
                ("j"  . pdf-view-next-page)
                ("k"  . pdf-view-previous-page)
                ("e"  . pdf-view-goto-page)
                ("u"  . pdf-view-revert-buffer)
                ("al" . pdf-annot-list-annotations)
                ("ad" . pdf-annot-delete)
                ("aa" . pdf-annot-attachment-dired)
                ("am" . pdf-annot-add-markup-annotation)
                ("at" . pdf-annot-add-text-annotation)
                ("y"  . pdf-view-kill-ring-save)
                ("i"  . pdf-misc-display-metadata)
                ("s"  . pdf-occur)
                ("b"  . pdf-view-set-slice-from-bounding-box)
                ("r"  . pdf-view-reset-slice)))
#+end_src

#+RESULTS:

** File manager

There is already an awesome file manager built in Emacs, called ~dired~.

By default it doesn't automatically refresh opened directories, so any
changes from the outside (e.g. file operations done in the command-line)
doesn't apppear and user needs to manually refresh buffers using ~g~.
One of the problems is, that this key binding doesn't work with evil.

#+BEGIN_SRC emacs-lisp
(setq global-auto-revert-non-file-buffers t)
(setq auto-revert-verbose nil)
#+END_SRC

In Vim, I was used to open and close NerdTree with ~C-n~. Side-tree
file managers sux but let's keep the shortcut.

#+BEGIN_SRC emacs-lisp
(general-nmap "C-n" 'dired-jump)
#+END_SRC

You will probably find these Evil keybindings useful.

| Key binding | Explanation                  |
|-------------+------------------------------|
| RET         | Open a file or directory     |
| +           | Create a directory           |
| d           | Mark a file to be deleted    |
| x           | Delete marked files          |
| -           | Jump to the parent directory |
| C           | Copy a file or directory     |
| R           | Rename a file or directory   |


TODO Prevent ^ from jumping to the parent directory
TODO Bind backspace for accessing the parent directory
TODO Find useful hacks here https://github.com/Fuco1/dired-hacks

The standard ~ls~ output is a bit too much verbose for casual use. Let's hide
the details by default. To manually show/hide them,
use ~M-x dired-hide-details-mode~.

#+BEGIN_SRC emacs-lisp
(use-package dired
  :hook (dired-mode . dired-hide-details-mode))
#+END_SRC

We can make Dired more beautiful and utilize the ~all-the-icons~ packge to
display filetype icons.

See https://github.com/jtbm37/all-the-icons-dired

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons-dired
  :ensure t
  :hook
  (dired-mode . all-the-icons-dired-mode))
#+END_SRC

To use ~dired~ as a full-fledged file manager for all desktop environment usage,
we need to admit, that there exists a world outside of Emacs and that we need to
open some file types with dedicated applications.

https://github.com/Fuco1/dired-hacks#dired-open

#+BEGIN_SRC emacs-lisp
(use-package dired-open
  :ensure t)
#+END_SRC

Explicitly assign file types to the applications that should open them. I find
this more reliable than ~xdg-open~ which has been doing weird shit every time I
touched it in the last ten years.

#+BEGIN_SRC emacs-lisp
(setq dired-open-extensions
      '(("gif" . "eog")
        ("jpg" . "eog")
        ("png" . "eog")
        ("mkv" . "vlc --one-instance")
        ("mp4" . "vlc --one-instance")
        ("ogv" . "vlc --one-instance")
        ("avi" . "vlc --one-instance")
        ("odt"  . "libreoffice")
        ("docx" . "libreoffice")
        ("docx" . "libreoffice")))
#+END_SRC

Sometimes we would like to open a file in different application (e.g. editting
an image instead of viewing it, queueing a video instead of starting it
immediately, etc). For that, it is nice to have an "open with" dialog that is
commonly used in GUI file managers.

See https://github.com/FrostyX/helm-dired-open

#+BEGIN_SRC emacs-lisp
(use-package helm-dired-open
  :ensure t
  :quelpa (helm-dired-open
           :fetcher github
           :repo "FrostyX/helm-dired-open"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my/dired-vlc-enqueue ()
  (interactive)
  (let ((file (ignore-errors (dired-get-file-for-visit))))
	(dired-open--start-process file "vlc --one-instance --playlist-enqueue")))
#+END_SRC

To make the ~dired~ output more exciting, we can add some colors to it. There is
an out-of-the-box solution in the form of ~diredfl~ package but that colorizes
dired heavily and I feel like I would have to de-colorize it a little.

See https://github.com/purcell/diredfl

My choice is ~dired-rainbow~ which allows us to colorize files by their type or
permissions but we need to manually opt-in for each.

See https://github.com/Fuco1/dired-hacks#dired-rainbow

#+BEGIN_SRC emacs-lisp
(use-package dired-rainbow
  :ensure t)
#+END_SRC

This package is immensely annoying in one aspect. Instead of always redefining
the filetype <-> groups and groups <-> faces associations on each
~dired-rainbow-define~, it preserves the previous configuration. Therefore once
we define a group of filetypes and set a color for them, we cannot adjust it
with the same command. For this reason, I am creating the groups and simply set
their colors to ~nil~. And only later specify their faces.

#+BEGIN_SRC emacs-lisp
(dired-rainbow-define img nil ("gif" "jpg" "png"))
(dired-rainbow-define video nil ("mp4" "mkv" "ogv" "avi"))
(dired-rainbow-define office nil ("odt" "doc" "docx"))
(dired-rainbow-define pdf nil ("pdf"))
#+END_SRC

Now we can adjust the file type and permission colors.

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'dired-rainbow-img-face nil :foreground my/green)
(set-face-attribute 'dired-rainbow-office-face nil :foreground my/yellow)
(set-face-attribute 'dired-rainbow-video-face nil :foreground my/orange)
(set-face-attribute 'dired-rainbow-pdf-face nil :foreground my/purple)
#+END_SRC

When using ~dired~ as an general purpose file manager, it is convenient to setup
bookmarks for non-project directories (e.g. movies and music folders).

| Command              | Explanation                                                  |
|----------------------+--------------------------------------------------------------|
| ~M-x bookmark-set~   | Create a bookmark                                            |
| ~M-x helm-bookmarks~ | List and jump to bookmarks                                   |
| ~M-x bookmark-save~  | Permanently save all bookmarks to ~$HOME/.emacs.d/bookmarks~ |

Highlight the whole cursor line when in ~dired~. I am blind as a bat and can't
easily read the whole filename by just having a cursor at the beginning of the line.

#+BEGIN_SRC emacs-lisp
(use-package dired
  :hook (dired-mode . hl-line-mode))
#+END_SRC

By default ~dired~ uses space for moving the cursor to the next line, we want to
unbind that so that hydra works.

#+BEGIN_SRC emacs-lisp
(general-unbind 'normal dired-mode-map
  "SPC"
  "S-SPC")
#+END_SRC

It is well-known that Emacs can open archives (.tar, .zip, etc) but thanks to
~archive-rpm~, it can browse also SRPM and RPM packages. This is a game changer.

See https://github.com/nbarrientos/archive-rpm

#+BEGIN_SRC emacs-lisp
(use-package archive-rpm
  :ensure t)
#+END_SRC

In Emacs 29, it will be possible to drag-and-drop files from dired to
other applications outside of Emacs (Images to browser, subtitles to
vlc, etc).

See https://www.reddit.com/r/emacs/comments/uq6gxy/comment/i8p3c0m/?utm_source=share&utm_medium=web2x&context=3

One of the most killer features in GUI file managers is a menu for mounting
removable disks such as USB sticks and external drives. Let's do this in Emacs
as well.

See https://gitlab.com/tuedachu/udiskie.el

First, install the Fedora package that is internally used.

#+BEGIN_SRC example
(frostyx/dnf :install "udiskie")
#+END_SRC

And install the Emacs ~udiskie~ pacakge

#+BEGIN_SRC emacs-lisp
(use-package udiskie
  :if workstation-p
  :ensure t
  :disabled t
  :quelpa (udiskie
           :fetcher git
           :url "https://gitlab.com/tuedachu/udiskie.el.git"))
#+END_SRC

** TODO Mailing
[[https://shom.dev/posts/20220108_setting-up-protonmail-in-emacs/][Setting up Protonmail in Emacs | shom.dev]]

*** mu4e

** Git gutter
#+begin_src emacs-lisp :lexical no
  (use-package git-gutter
  	:ensure t
    :hook (prog-mode . git-gutter-mode)
    :config
    (setq git-gutter:update-interval 0.02))

  (use-package git-gutter-fringe
  	:ensure t
  	:config
    (define-fringe-bitmap 'git-gutter-fr:added [224] nil nil '(center repeated))
    (define-fringe-bitmap 'git-gutter-fr:modified [224] nil nil '(center repeated))
    (define-fringe-bitmap 'git-gutter-fr:deleted [128 192 224 240] nil nil 'bottom))
#+end_src

#+RESULTS:
: t

** Org reveal
#+begin_src emacs-lisp :lexical no
  (use-package ox-reveal
  	:ensure t)
#+end_src

#+RESULTS:

#+begin_src example
  (use-package org-reveal
    :ensure t
    :quelpa (org-reveal
             :fetcher github
             :repo "yjwen/org-reveal"
             :branch "master"))
#+end_src

** Telega.el
#+begin_src shell
  paru -S telegram-tdlib # TDLib will be installed into /usr
#+end_src

#+begin_src emacs-lisp :lexical no
    (use-package telega
      :ensure t
      :commands (telega)
      :config
      (setq telega-use-docker t))
#+end_src

#+RESULTS:
: t

** RSS

Probably the best available RSS client for Emacs is elfeed. It allows
asynchronious sync, automatical refresh by using internal timers, and more.
It provides a user-interface decoupled from the backend logic so we have an
opportunity to implement our own views.

#+BEGIN_SRC example
(use-package elfeed
  :if workstation-p
  :ensure t
  :commands (elfeed)
  :config
  (setq-default elfeed-search-filter ""))
#+END_SRC

Managing our RSS feeds in org file is much more cool than having them in
a list of lists.

#+BEGIN_SRC example
(use-package elfeed-org
  :if workstation-p
  :ensure t
  :config
  (elfeed-org))
#+END_SRC

#+BEGIN_SRC example
(setq rmh-elfeed-org-files (list "~/.emacs.d/elfeed.org"))
#+END_SRC

#+RESULTS:
| ~/.emacs.d/elfeed.org |

We have so many feeds subscribed and not enough time to read them
all. By default show only the work-related articles.

#+BEGIN_SRC example
(setq elfeed-search-filter "+work")
#+END_SRC

Automatically fetch updates from RSS feeds. Let's do it every day, but I am
afraid, that it will lag the whole Emacs, so we will probably need to adjust it
and run less frequently.

See:
- https://github.com/skeeto/elfeed/issues/304
- https://www.reddit.com/r/emacs/comments/bvbp92/is_there_a_simple_way_to_get_elfeed_to_update/

#+BEGIN_SRC example
(setq my/elfeed-update-timer
  (run-at-time nil (* 1 60 60 24) #'elfeed-update))
#+END_SRC

Use ~M-x helm-timers~ to see (and cancel) executed timers.

Very likely we will need to execute operation accross every displayed article

See https://emacs.stackexchange.com/a/2441

#+BEGIN_SRC example
(defun elfeed-apply-for-all (f)
  (interactive)
  (mark-whole-buffer)
  (f))
#+END_SRC

Such as marking everything as read

#+BEGIN_SRC example
(defun elfeed-mark-all-as-read ()
  (elfeed-apply-for-all elfeed-search-untag-all-unread))
#+END_SRC

You will probably find these keybindings useful.

| Key binding | Explanation                   |
|-------------+-------------------------------|
| RET         | Open article in elfeed        |
| o           | Open article in a web browser |
| r           | Fetch new articles            |
| u           | Mark article as read          |
| U           | Mark article as unread        |
| +           | Add tag                       |
| -           | Remove tag                    |
| S           | Stop all fetching processes   |

Define custom key bindings for the list of articles

#+BEGIN_SRC example
(with-eval-after-load "elfeed-search"
  (evil-define-key*
    'normal elfeed-search-mode-map
    "RET" #'elfeed-search-show-entry
    "o" #'elfeed-search-browse-url
    "r" #'elfeed-search-fetch
    "S" #'elfeed-unjam))
#+END_SRC

Define custom key bindings for when reading an article

#+BEGIN_SRC example
(with-eval-after-load "elfeed-show"
  (evil-define-key*
    'motion elfeed-show-mode-map
    "gb" #'elfeed-show-visit
    "gj" #'elfeed-show-next
    "gk" #'elfeed-show-prev))
#+END_SRC

Finally, customize colors

#+BEGIN_SRC example
(set-face-attribute
 'elfeed-search-date-face nil
 :foreground my/blue)

(set-face-attribute
 'elfeed-search-title-face nil
 :foreground "#d0d0d0") ;; Normal text foreground, we should define it somewhere

(set-face-attribute
 'elfeed-search-feed-face nil
 :foreground my/blue)

(set-face-attribute
 'elfeed-search-tag-face nil
 :foreground my/green)

(set-face-attribute
 'elfeed-search-unread-title-face nil
 :foreground my/purple
 :weight 'normal
 :width 'normal)
#+END_SRC

Don't show any date, we don't have enough space for that

#+BEGIN_SRC emacs-lisp
(defun elfeed-search-format-date (date)
  "")
#+END_SRC

We also need a less space for article authors in favor of their
titles.

#+BEGIN_SRC emacs-lisp
(setq elfeed-search-trailing-width 15)
#+END_SRC

I want to customize the columns order but ~elfeed~ doesn't support such thing
yet. We need to re-implement the whole displaying function.

#+BEGIN_SRC emacs-lisp
(setq elfeed-search-print-entry-function #'frostyx/elfeed-search-print-entry)

(defun frostyx/elfeed-search-print-entry (entry)
  "Print ENTRY to the buffer."
  (let* ((date (elfeed-search-format-date (elfeed-entry-date entry)))
         (title (or (elfeed-meta entry :title) (elfeed-entry-title entry) ""))
         (title-faces (elfeed-search--faces (elfeed-entry-tags entry)))
         (feed (elfeed-entry-feed entry))
         (feed-title
          (when feed
            (or (elfeed-meta feed :title) (elfeed-feed-title feed))))
         (tags (mapcar #'symbol-name (elfeed-entry-tags entry)))
         (tags-str (mapconcat
                    (lambda (s) (propertize s 'face 'elfeed-search-tag-face))
                    tags ","))
         (title-width (- (window-width) 10 elfeed-search-trailing-width))
         (title-column (elfeed-format-column
                        title (elfeed-clamp
                               elfeed-search-title-min-width
                               title-width
                               elfeed-search-title-max-width)
                        :left)))
    (insert (propertize date 'face 'elfeed-search-date-face) " ")
    ;; The whole function is copy-pasted `elfeed-search-print-entry--default',
    ;; just the following lines are changed
    (when feed-title
      (insert (string-pad
               (propertize feed-title 'face 'elfeed-search-feed-face) 15)))
    (insert (propertize title-column 'face title-faces 'kbd-help title) " ")
    (when tags
      (insert "(" tags-str ")"))))
#+END_SRC
** Desktop notifications

See https://github.com/sinic/ednc

The package is in MELPA but I am installing from my fork because of a
custom changes.

See https://github.com/sinic/ednc/pull/12

#+BEGIN_SRC emacs-lisp
(use-package ednc
  :quelpa (ednc
           :fetcher github
           :repo "FrostyX/ednc"
           :branch "ednc-faces")
  :config
  (ednc-mode 1))
#+END_SRC

Use pretty colors

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'ednc-app-name nil :foreground my/blue)
(set-face-attribute 'ednc-title nil :foreground my/green)
(set-face-attribute 'ednc-body nil :foreground my/yellow)
#+END_SRC

Setup some basic key bindings

#+BEGIN_SRC emacs-lisp
(general-nmap
  :keymaps 'ednc-view-mode-map
  "TAB" 'ednc-toggle-expanded-view)
#+END_SRC

For debugging, you can send a notification from Emacs like this

#+BEGIN_src example
(notifications-notify
 :app-name "EDNC"
 :title "1st test"
 :body "hello, world"
 :urgency "normal")
#+END_src

#+RESULTS:
: 2

I don't know how exactly the Linux notification system works but it
seems there cannot be multiple daemons listening at the same time. If
you don't see any notifications, check whether the daemon runs in
another Emacs instance, or whether another daemon is running (Dunst,
Qtile widget, etc).

I want the log buffer to automatically scroll down, similarly like
~tail -f~ works.

See https://stackoverflow.com/a/12666854/3285282

#+BEGIN_SRC emacs-lisp
(defun frostyx/autoscroll ()
  (set (make-local-variable 'window-point-insertion-type) t))

(add-hook 'ednc-view-mode-hook 'frostyx/autoscroll)
#+END_SRC
** CNCL Ement
#+begin_src example :lexical no
  (use-package taxy-magit-section
  	:ensure t)

  (use-package ement
    :quelpa (ement :fetcher github :repo "alphapapa/ement.el"))
#+end_src

** RSS Youtube

See https://github.com/karthink/elfeed-tube

#+BEGIN_SRC example
(use-package elfeed-tube
  :ensure t
  :after elfeed
  :demand t
  :config
  (elfeed-tube-setup)

  :bind (:map elfeed-show-mode-map
         ("F" . elfeed-tube-fetch)
         ([remap save-buffer] . elfeed-tube-save)
         :map elfeed-search-mode-map
         ("F" . elfeed-tube-fetch)
         ([remap save-buffer] . elfeed-tube-save)))
#+END_SRC

** Elfeed Web UI

See https://github.com/skeeto/elfeed?tab=readme-ov-file#web-interface

#+BEGIN_SRC example
(use-package elfeed-web
  :ensure t)
#+END_SRC

The default port is 8080 which clashes with too many projects that I
develop.

#+BEGIN_SRC example
(setq httpd-port 8090)
(setq httpd-host "0.0.0.0")
#+END_SRC

Start the server. We need to ignore the errors because running a second Emacs
instance would fail that the port is already used.

#+BEGIN_SRC example
(ignore-error
  (elfeed-web-start))
#+END_SRC

The web interface is available at http://localhost:8090/elfeed/

The main motivation is to be able to access Elfeed from my phone
https://play.google.com/store/apps/details?id=com.elfeedcljsrn
When starting it, use the only the host and port, without the
~/elfeed/~ part.

* Reverse im
#+begin_src emacs-lisp :lexical no
  ;; Needed for `:after char-fold' to work
  ;; (use-package char-fold
  ;; 	:ensure t
  ;;   :custom
  ;;   (char-fold-symmetric t)
  ;;   (search-default-mode #'char-fold-to-regexp))

  (use-package reverse-im
    ;; :ensure t ; install `reverse-im' using package.el
    :quelpa (reverse-im
             :fetcher github
             :repo "emacsmirror/reverse-im")
    :demand t
    ;;:after char-fold ; but only after `char-fold' is loaded
    :custom
    (reverse-im-cache-file (locate-user-emacs-file "reverse-im-cache.el"))
    (reverse-im-char-fold t)
    (reverse-im-read-char-advice-function #'reverse-im-read-char-include)
    (reverse-im-input-methods '("ukrainian-computer"))
    :config
    (reverse-im-mode t)) ; turn the mode on
#+end_src

#+RESULTS:
: t

* Project management
** Projectile

When working on multiple projects at the same time, it is useful keep some level
of separation between them. This is where ~projectile~ comes handy. It allows you
to easily filter buffers, search files, work with tags and do many more action
within a current project.

As a project is considered every git (or other SCM) repository, or a directory
containing a ~.projectile~ file in it.

See https://github.com/bbatsov/projectile

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :config
  (setq projectile-project-search-path '("~/Templates/")))
#+END_SRC

#+RESULTS:
: t

TODO Discover projects on startup

The default projectile interface is /meh/ at best, let's use helm.

See https://github.com/bbatsov/helm-projectile

#+BEGIN_SRC example emacs-lisp
(use-package helm-projectile
  :ensure t)
#+END_SRC

#+RESULTS:
: t

* Interface
** GUI
Disable all the GUI nonsense. Even though we are running graphical version of Emacs,
we want to be #mouseless and have the UI to look as close to terminal as possible.

Get rid of menu, scrollbars, toolbars and everything that can be clicked on.

#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(customize-set-variable 'scroll-bar-mode nil)
(customize-set-variable 'horizontal-scroll-bar-mode nil)
#+END_SRC

** Fonts

#+BEGIN_SRC emacs-lisp
  (defun frostyx/set-default-font (size)
    (set-face-attribute
     'default nil
     :family "Iosevka"
     ;;:foundry "ADBO"
     :height 150 ;;size
     :weight 'regular ;;'normal
     :width 'normal
     :slant 'normal
     ;;:foreground (plist-get base16-chalk-theme-colors :base05)
  ))
#+END_SRC

#+RESULTS:
: frostyx/set-default-font

#+BEGIN_SRC emacs-lisp
(frostyx/set-default-font 90)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'lazy-highlight nil :background my/orange
                                        :foreground my/gray)
#+END_SRC

** Dashboard
#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :after all-the-icons
    :ensure t
    :defer nil
    :config
    (setq dashboard-banner-logo-title "Welcome back, Darling!"
          dashboard-startup-banner "~/.emacs.d/images/Emacs-logo.svg"
          dashboard-center-content    t
          dashboard-show-shortcuts    t
          dashboard-set-navigator     nil
          dashboard-set-heading-icons t
          initial-buffer-choice       (lambda () (get-buffer "*dashboard*"))
          dashboard-set-file-icons    t)
    (setq dashboard-items '((recents  . 12)
                            ;; (agenda   . 6)
                            (projects . 6))))

  (dashboard-setup-startup-hook)
#+END_SRC

** Icons and Emojis

Besides normal fonts we also want to setup some icon fonts. Personally, I like
~Font Awesome~ the best. It is really easy to use and it dominates in the realm
of website icons so it is like killing two birds with one stone.

See https://github.com/emacsorphanage/fontawesome

#+BEGIN_SRC emacs-lisp
  (use-package fontawesome
    ;; :disabled nil
    :ensure t)
#+END_SRC

By default ~Font Awesome~ icons show quite strangely. It seems that all icons
work, it's just they are displayed under wrong names. In ~M-x helm-fontawesome~
it works properly though. The following setting fixes it.

See https://github.com/emacsorphanage/fontawesome/issues/12#issuecomment-284193735

Not doing this though because it breaks ~all-the-icons~ filetype icons.

See https://www.reddit.com/r/emacs/comments/pdviti/why_are_alltheicons_displaying_wrong_icons/

#+BEGIN_SRC emacs-lisp
 (set-fontset-font t 'unicode "FontAwesome" nil 'prepend)
#+END_SRC

The most commonly used collection of icons in Emacs is ~all-the-icons~. It
encapsulates FontAwesome, filetype icons, major mode icons, and more. If the
icons are not displayed correctly, run ~M-x all-the-icons-install-fonts~.

See https://github.com/domtronn/all-the-icons.el

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons
    :defer t
    :ensure t)
#+END_SRC

#+RESULTS:

** Symbols
#+BEGIN_SRC emacs-lisp
(use-package ligature
  :ensure t
  :config
  ;; Enable the "www" ligature in every possible major mode
  (ligature-set-ligatures 't '("www"))
  ;; Enable traditional ligature support in eww-mode, if the
  ;; `variable-pitch' face supports it
  (ligature-set-ligatures 'eww-mode '("ff" "fi" "ffi"))
  ;; Enable all Cascadia Code ligatures in programming modes
  (ligature-set-ligatures 'prog-mode '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                                       ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                                       "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                                       "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                                       "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                                       "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                                       "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                                       "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                                       ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                                       "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                                       "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                                       "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
                                       "\\\\" "://"))
  ;; Enables ligature checks globally in all buffers. You can also do it
  ;; per mode with `ligature-mode'.
  (global-ligature-mode t))
#+END_SRC

** Modeline
:PROPERTIES:
:ORDERED:  t
:END:
:LOGBOOK:
CLOCK: [2024-11-14 Чт 15:06]--[2024-11-14 Чт 15:06] =>  0:00
CLOCK: [2024-11-14 Чт 15:05]--[2024-11-14 Чт 15:05] =>  0:00
CLOCK: [2024-11-14 Чт 15:05]--[2024-11-14 Чт 15:05] =>  0:00
CLOCK: [2024-11-14 Чт 14:44]--[2024-11-14 Чт 15:02] =>  0:18
CLOCK: [2024-11-14 Чт 14:44]--[2024-11-14 Чт 14:44] =>  0:00
CLOCK: [2024-10-21 Пн 18:21]--[2024-10-21 Пн 18:21] =>  0:00
CLOCK: [2024-08-09 Пт 01:05]--[2024-08-09 Пт 01:05] =>  0:00
CLOCK: [2024-08-09 Пт 01:04]--[2024-08-09 Пт 01:04] =>  0:00
CLOCK: [2024-08-09 Пт 01:03]--[2024-08-09 Пт 01:03] =>  0:00
CLOCK: [2024-08-09 Пт 01:02]--[2024-08-09 Пт 01:02] =>  0:00
CLOCK: [2024-08-09 Пт 01:02]--[2024-08-09 Пт 01:02] =>  0:00
:END:

See https://dev.to/gonsie/beautifying-the-mode-line-3k10

#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
  :ensure t
  :init
  (doom-modeline-mode 1))
#+END_SRC

Some basic modeline customizations

#+BEGIN_SRC emacs-lisp
;; Make it smaller
(setq doom-modeline-height 22)

;; By default the icons are larger than the rest of the text, we don't want that
(setq all-the-icons-scale-factor 1.0)

;; Don't show icons, I have some bug rendering them incorrectly
(setq doom-modeline-icon nil)

;; Display only buffer names, not full paths
(setq doom-modeline-buffer-file-name-style 'buffer-name)

;; Don't show buffer encoding
(setq doom-modeline-buffer-encoding nil)

;; Don't show any mess next to major-mode
(setq doom-modeline-env-version nil)
#+END_SRC

#+RESULTS:

General modeline (non doom-modeline specific) settings

#+BEGIN_SRC example
(set-face-attribute
 'mode-line nil
 :background my/gray)

(set-face-attribute
 'mode-line-inactive nil
 :foreground my/lgray
 :background my/gray)
#+END_SRC

#+RESULTS:

No bold or italic texts and other font configurations

#+BEGIN_SRC example
(set-face-attribute
 'doom-modeline-emphasis nil
 :weight 'normal
 :slant 'normal)

(set-face-attribute
 'doom-modeline-bar nil)

(set-face-attribute
 'doom-modeline-buffer-file nil
 :weight 'normal)

(set-face-attribute
 'doom-modeline-buffer-modified nil
 :weight 'normal)

(set-face-attribute
 'doom-modeline-buffer-major-mode nil
 :foreground my/orange)
#+END_SRC

Configure fonts for the evil segment

#+BEGIN_SRC example
(set-face-attribute
 'doom-modeline-evil-normal-state nil
 :background my/gray
 :foreground my/orange)

(set-face-attribute
 'doom-modeline-evil-emacs-state nil
 :background my/gray
 :foreground my/blue)

(set-face-attribute
 'doom-modeline-evil-insert-state nil
 :background my/gray
 :foreground my/green)

(set-face-attribute
 'doom-modeline-evil-replace-state nil
 :background my/gray
 :foreground my/blue)

(set-face-attribute
 'doom-modeline-evil-motion-state nil
 :background my/gray
 :foreground my/blue)

(set-face-attribute
 'doom-modeline-evil-visual-state nil
 :background my/gray
 :foreground my/purple)
#+END_SRC

#+RESULTS:

#+RESULTS:
: doom-modeline--frostyx-org-agenda-update

#+begin_src emacs-lisp :lexical no
  (use-package nerd-icons
    :ensure)
#+end_src

#+RESULTS:

Custom segments will be defined further down in this config file. In
order to not fail with undefined variable errors, let's just
mock-define them for now.

Segments in the modeline can be placed into 3 separate groups - left,
middle, and right. The left group is somewhat non-customizable, here
comes the configuration of the middle

#+begin_src example :lexical no
    (defvar frostyx-org-agenda-count "")

(defun frostyx-org-agenda-count-update ()
  "Update the count of tasks marked as NEXT and IN-PROGRESS from the org file."
  (let ((next-count 0)
        (in-progress-count 0)
        (org-file "~/Org/agenda/GTD/org-gtd-tasks.org"))
    (when (file-exists-p org-file)
      (with-current-buffer (find-file-noselect org-file)
        (org-eldoom-modeline-def-modeline 'main
            frostyx/doom-modeline-middle-segments
            frostyx/doom-modeline-right-segments)
#+END_SRC

#+RESULTS:
: doom-modeline-format--main

Define modeline for helm

#+BEGIN_SRC example
  (doom-modeline-def-modeline 'helm
    '(helm-buffer-id helm-number helm-follow helm-prefix-argument)
    '(helm-help time))
#+END_SRC

Don't use any pre-defined modelines for various major modes. We will
define our own later, though.

#+BEGIN_SRC emacs-lisp
(setq doom-modeline-mode-alist '())
#+END_SRC
*** Hide modeline
#+BEGIN_SRC emacs-lisp
  (use-package hide-mode-line
    :ensure t
    :config
    (evil-leader/set-key
      "h" 'global-hide-mode-line-mode))
#+END_SRC

#+RESULTS:
: t

** Olivetti
#+BEGIN_SRC emacs-lisp
  (use-package olivetti
    :ensure t
    :defer t
    :hook ((text-mode         . olivetti-mode)
           ;; (org-agenda-mode   . olivetti-mode)
           (prog-mode         . olivetti-mode)
           (Info-mode         . olivetti-mode)
           (org-mode          . olivetti-mode)
           (nov-mode          . olivetti-mode)
           (markdown-mode     . olivetti-mode)
           (mu4e-view-mode    . olivetti-mode)
           (elfeed-show-mode  . olivetti-mode))
    :config
    (setq olivetti-body-width 150))
#+END_SRC

#+RESULTS:
| olivetti-mode |

** Treemacs
#+BEGIN_SRC emacs-lisp
  (use-package treemacs
    :ensure t
    :defer t
    :init
    (with-eval-after-load 'winum
      (define-key winum-keymap (kbd "M-0") #'treemacs-select-window))
    :config
    (progn
      (setq treemacs-collapse-dirs                   (if treemacs-python-executable 3 0)
            treemacs-deferred-git-apply-delay        0.5
            treemacs-directory-name-transformer      #'identity
            treemacs-display-in-side-window          t
            treemacs-eldoc-display                   'simple
            treemacs-file-event-delay                2000
            treemacs-file-extension-regex            treemacs-last-period-regex-value
            treemacs-file-follow-delay               0.2
            treemacs-file-name-transformer           #'identity
            treemacs-follow-after-init               t
            treemacs-expand-after-init               t
            treemacs-find-workspace-method           'find-for-file-or-pick-first
            treemacs-git-command-pipe                ""
            treemacs-goto-tag-strategy               'refetch-index
            treemacs-header-scroll-indicators        '(nil . "^^^^^^")
            treemacs-hide-dot-git-directory          t
            treemacs-indentation                     2
            treemacs-indentation-string              " "
            treemacs-is-never-other-window           nil
            treemacs-max-git-entries                 5000
            treemacs-missing-project-action          'ask
            treemacs-move-forward-on-expand          nil
            treemacs-no-png-images                   nil
            treemacs-no-delete-other-windows         t
            treemacs-project-follow-cleanup          nil
            treemacs-persist-file                    (expand-file-name ".cache/treemacs-persist" user-emacs-directory)
            treemacs-position                        'left
            treemacs-read-string-input               'from-child-frame
            treemacs-recenter-distance               0.1
            treemacs-recenter-after-file-follow      nil
            treemacs-recenter-after-tag-follow       nil
            treemacs-recenter-after-project-jump     'always
            treemacs-recenter-after-project-expand   'on-distance
            treemacs-litter-directories              '("/node_modules" "/.venv" "/.cask")
            treemacs-project-follow-into-home        nil
            treemacs-show-cursor                     nil
            treemacs-show-hidden-files               t
            treemacs-silent-filewatch                nil
            treemacs-silent-refresh                  nil
            treemacs-sorting                         'alphabetic-asc
            treemacs-select-when-already-in-treemacs 'move-back
            treemacs-space-between-root-nodes        t
            treemacs-tag-follow-cleanup              t
            treemacs-tag-follow-delay                1.5
            treemacs-text-scale                      nil
            treemacs-user-mode-line-format           nil
            treemacs-user-header-line-format         nil
            treemacs-wide-toggle-width               70
            treemacs-width                           35
            treemacs-width-increment                 1
            treemacs-width-is-initially-locked       t
            treemacs-workspace-switch-cleanup        nil)

      ;; The default width and height of the icons is 22 pixels. If you are
      ;; using a Hi-DPI display, uncomment this to double the icon size.
      ;;(treemacs-resize-icons 44)

      (treemacs-follow-mode t)
      (treemacs-filewatch-mode t)
      (treemacs-fringe-indicator-mode 'always)
      (when treemacs-python-executable
        (treemacs-git-commit-diff-mode t))

      (pcase (cons (not (null (executable-find "git")))
                   (not (null treemacs-python-executable)))
        (`(t . t)
         (treemacs-git-mode 'deferred))
        (`(t . _)
         (treemacs-git-mode 'simple)))

      (treemacs-hide-gitignored-files-mode nil))
    :bind
    (:map global-map
          ("M-0"       . treemacs-select-window)
          ("C-x t 1"   . treemacs-delete-other-windows)
          ("C-x t t"   . treemacs)
          ("C-x t d"   . treemacs-select-directory)
          ("C-x t B"   . treemacs-bookmark)
          ("C-x t C-t" . treemacs-find-file)
          ("C-x t M-t" . treemacs-find-tag)))
#+END_SRC

#+RESULTS:
: treemacs-find-tag

** Helm

#+BEGIN_SRC emacs-lisp
  (use-package helm
    :ensure t
    :config
    (helm-mode 1)
    (setq helm-autoresize-mode t)
    (setq helm-buffer-max-length 40)
    (setq helm-locate-fuzzy-match t)


    (global-set-key (kbd "M-x") #'helm-M-x)
    (define-key helm-map (kbd "S-SPC") 'helm-toggle-visible-mark)
    ; (define-key helm-find-files-map (kbd "C-k") 'helm-find-files-up-one-level)

    (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to do persistent action
    (define-key helm-map (kbd "TAB") #'helm-execute-persistent-action)
    (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z

    ; http://cachestocaches.com/2016/12/vim-within-emacs-anecdotal-guide/
    (define-key helm-map (kbd "C-j") 'helm-next-line)
    (define-key helm-map (kbd "C-k") 'helm-previous-line)
    (define-key helm-map (kbd "C-h") 'helm-next-source)

    (define-key helm-map [escape] 'helm-keyboard-quit)

    ; (define-key helm-map (kbd "C-S-h") 'describe-key)
    ; (define-key helm-map (kbd "C-l") (kbd "RET"))
    ; (dolist (keymap (list helm-find-files-map helm-read-file-map))
          ; (define-key keymap (kbd "C-l") 'helm-execute-persistent-action)
          ; (define-key keymap (kbd "C-h") 'helm-find-files-up-one-level)
          ; (define-key keymap (kbd "C-S-h") 'describe-key))


  )
#+END_SRC

Helm introduced some "Emacs Command History" section in ~M-x~ and it
doesn't automatically move cursor to the "Emacs Commands" section when
simply pressing down arrow. This fixes it.

#+BEGIN_SRC emacs-lisp
(setq helm-move-to-line-cycle-in-source nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package helm-posframe
  :ensure t
  :disabled
  :config
  (helm-posframe-enable)
  (setq helm-posframe-poshandler
        #'posframe-poshandler-frame-center)
  (setq helm-posframe-width 200)
  (setq helm-posframe-height 600)
  (setq helm-posframe-parameters
        '((left-fringe . 10)
          (right-fringe . 10))))
#+END_SRC

Unfortunatelly, ~helm-posframe~ is quite buggy and breaks tab-completion for
~M-:~, takes a lot of time to appear, sometimes it appears empty or
whatelse. Let's try to stick with a small helm window at the bottom.

See https://github.com/emacs-helm/helm/issues/2039#issuecomment-390077931

#+BEGIN_SRC emacs-lisp
(defvar spacemacs-helm-display-help-buffer-regexp '("\\*.*Helm.*Help.*\\*"))
(defvar spacemacs-helm-display-buffer-regexp `("\\*.*helm.*\\*"
                                               (display-buffer-in-side-window)
                                               (inhibit-same-window . nil)
                                               (side . bottom)
                                               (window-width . 0.6)
                                               (window-height . 0.6)))

(defun display-helm-at-bottom (buffer &optional _resume)
  (let ((display-buffer-alist (list spacemacs-helm-display-help-buffer-regexp
                                    spacemacs-helm-display-buffer-regexp)))
    (display-buffer buffer)))
(setq helm-display-function 'display-helm-at-bottom)
#+END_SRC

And finally, we want to show a limited number of results.

See https://github.com/emacs-helm/helm/wiki/helm-autoresize

#+BEGIN_SRC emacs-lisp
(helm-autoresize-mode 1)
(setq helm-autoresize-max-height 40)
(setq helm-autoresize-min-height 40)
#+END_SRC

Buffer management is a bread and butter of every text editor. This is true even
more for Emacs because we tend to live in it. Everything is a buffer.
I don't want to navigate through a mess of all things that I've opened this week
every time I want to switch a buffer.

Most times, there is a high probability to guess, what we are currently
interested in. Are we working in a project? Are we in the dired mode? Are we
chatting on IRC?

#+BEGIN_SRC emacs-lisp
(defun my/smart-buffers-list ()
  (interactive)
  (cond ((derived-mode-p 'lui-mode) (my/circe-switch-to-buffer))

        ((derived-mode-p 'vterm-mode)
         (if (projectile-project-root)
             (frostyx/projectile-switch-to-vterm-buffer)
           (frostyx/switch-to-vterm-buffer)))

        ((derived-mode-p 'ement-room-list-mode
                         'ement-room-mode
                         'ement-directory-mode)
         (helm-ement-buffers))

        ((projectile-project-root) (consult-project-buffer))
        (t (consult-buffer))))
#+END_SRC

We have a key binding for our smarty-pants buffer-switching command which should
be suitable for 99% of cases and for the rest, there is a fallback showing all
open buffers without any filter.

#+BEGIN_SRC emacs-lisp
(general-nmap ";"  'my/smart-buffers-list)
(general-nmap ",;" 'consult-buffer)
#+END_SRC

** Which-key

Nobody can really remember all the Emacs key chords. Let's use
~which-key~ to show us a nice little help once we start some chord and
get stuck remembering how it goes next.

See https://github.com/justbur/emacs-which-key

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :config
  (which-key-mode))
#+END_SRC

* Development

#+BEGIN_SRC emacs-lisp
(use-package fic-mode
  :ensure t
  :config
  (add-hook 'prog-mode-hook 'fic-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  ;; There is a bug visualizing even #def in .Xdefaults
  :ensure t
  :config
  nil)
#+END_SRC

In many programming languages there is a standard line width and code should not
continue over it. Also when writting a text (e.g. documentation) it is better to
hard-wrap the lines somewhere. It makes a review easier, it is much clearer in
diffs, ets. Typically we wrap at 80, 100 or 120 characters.

#+BEGIN_SRC emacs-lisp
(use-package fill-column-indicator
  :ensure t
  :config
  (setq fci-rule-width 1)
  (setq fci-rule-color my/gray))
#+END_SRC

Let's define a function which will color a given column

#+BEGIN_SRC emacs-lisp
(defun my/colorcolumn (column)
  (turn-on-fci-mode)
  (set-fill-column column))
#+END_SRC

The ~fill-column-mode~ shouldn't be used, we now have
~display-fill-column-indicator-mode~ built in the Emacs itself.

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'fill-column-indicator nil :foreground my/lgray)
#+END_SRC

** Indentation

Disable ~electric-indent-mode~ because it is trying to be smart and do weird
aggressive indents that are in fact just stupid and only makes me manually remove
and adjust them. Also make sure, that any major mode won't turn it on again.

#+BEGIN_SRC emacs-lisp
(electric-indent-mode -1)
(add-hook 'after-change-major-mode-hook (lambda() (electric-indent-mode -1)))
#+END_SRC

By default, use spaces, not tabs

#+BEGIN_SRC example
(setq-default indent-tabs-mode nil)
#+END_SRC

Set tab width and other indentation settings based on the analysis of the
current project.

#+BEGIN_SRC emacs-lisp
(use-package dtrt-indent
  :ensure t
  :config
  (dtrt-indent-global-mode)
  (dtrt-indent-adapt))
#+END_SRC

Map ~ENTER~ key to execute ~newline-and-indent~ in order to eliminate different
indentation from ~ENTER~ and pressing Evil ~o~ command. Hopefully they are the
same, we need some longer observation.

TODO map this for all modes?

#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "RET") 'newline-and-indent)
#+END_SRC

In case a project uses TABs for indenting, we want to see them with some
reasonable size.

#+BEGIN_SRC emacs-lisp
(setq tab-width 2)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun hook-tab-width ()
  (setq tab-width 2)
  (setq evil-shift-width 2)
  (setq python-indent-offset 2))
(add-hook 'prog-mode-hook #'hook-tab-width)
#+END_SRC

We need to adjust tab width for Evil ~<<~ and ~>>~ separately.

#+BEGIN_SRC emacs-lisp
(setq evil-shift-width 2)
#+END_SRC

And lastly, we need to adjust tab width for indenting using ~TAB~ key.

#+BEGIN_SRC emacs-lisp
(setq python-indent-offset 2)
#+END_SRC

** Completion (Company)

Our completion framework of choice is ~company~.

See https://company-mode.github.io/

#+BEGIN_SRC emacs-lisp
    (use-package company
      :ensure t
      :hook
      (company-mode . frostyx/company-mode-hook)
      :config
  ;; Company mode
  (setq company-idle-delay 0)
  (setq company-minimum-prefix-length 1)

  ;; Go - lsp-mode
  ;; Set up before-save hooks to format buffer and add/delete imports.
  (defun lsp-go-install-save-hooks ()
    (add-hook 'before-save-hook #'lsp-format-buffer t t)
    (add-hook 'before-save-hook #'lsp-organize-imports t t))
  (add-hook 'go-mode-hook #'lsp-go-install-save-hooks)

  ;; Start LSP Mode and YASnippet mode
  (add-hook 'go-mode-hook #'lsp-deferred)
  (add-hook 'go-mode-hook #'yas-minor-mode))
#+END_SRC

#+RESULTS:
| company-mode-set-explicitly | company-box-mode | frostyx/company-mode-hook |

When ~company-mode~ is activated for a buffer, use do some
configuration, such as, changing ~C-n~ to use it. Also automatically
insert candidates while ~C-n~ and ~C-p~ through them.

#+BEGIN_SRC emacs-lisp
(defun frostyx/company-mode-hook ()
  (setq-local evil-complete-next-func 'frostyx/company-complete))
#+END_SRC

Unfortunatelly we cannot use the default ~company-complete~ because it
takes no arguments.

#+BEGIN_SRC emacs-lisp
(defun frostyx/company-complete (&optional arg)
  (interactive)
  (company-complete-common-or-cycle))
#+END_SRC

For the love of god, be case-sensitive. This setting IMHO applies only
to plain text completions.

#+BEGIN_SRC emacs-lisp
(setq company-dabbrev-ignore-case nil)
(setq company-dabbrev-downcase nil)
#+END_SRC

Make the icons less disruptive and cooler

#+BEGIN_SRC emacs-lisp
(setq company-icon-margin 3)
#+END_SRC

Automatically insert candidates while ~C-n~ and ~C-p~ through them.

#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook 'company-tng-mode)
#+END_SRC

We need to turn off the auto configuration because it messes up with
brackets. But now we need to remap the ~company-active-map~ manually
otherwise pressing ~RET~ without selecting a candiate does nothing
(instead of simply inserting a new line)

#+BEGIN_SRC emacs-lisp
(setq company-tng-auto-configure nil)
(with-eval-after-load 'company-tng
  (setq company-active-map company-tng-map))
#+END_SRC

Use ~company-mode~ everywhere

#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook 'global-company-mode)
#+END_SRC

Use ~company-box~ it automatically shows documentation

#+BEGIN_SRC emacs-lisp
(use-package company-box
  :ensure t
  :hook
  (company-mode . company-box-mode)

  :config
  (setq company-box-icon-right-margin 1))
#+END_SRC

Make ~company-box-mode~ play well with ~company-tng-mode~.
See https://github.com/sebastiencs/company-box/issues/47

#+BEGIN_SRC emacs-lisp
(setq company-frontends '(company-tng-frontend company-box-frontend))
#+END_SRC

*** Company for org-mode
#+begin_src emacs-lisp
  (use-package company-org-block
    :ensure t
    :defer t
    :custom
    (company-org-block-edit-style 'auto) ;; 'auto, 'prompt, or 'inline
    :hook ((org-mode . (lambda ()
                         (setq-local company-backends '(company-org-block))
                         (company-mode +1)))))
#+end_src

#+RESULTS:
| (lambda nil (setq-local company-backends '(company-org-block)) (company-mode 1)) | toc-org-mode | org-appear-mode | org-modern-mode | ma/org-buffer-setup | org-tempo-setup | olivetti-mode | #[0 \301\211\207 [imenu-create-index-function org-imenu-get-tree] 2] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-fold-show-all append local] 5] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes | org-eldoc-load |

** Version control

Sometimes it might be useful to visualize git changes within a file
(new and changed lines).

Use ~M-x diff-hl-mode~

#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :ensure t)
#+END_SRC

** Flycheck

It is handy to have some on-fly syntax and style checker in order to not
produce ugly code.

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t)
#+END_SRC

Such tools are typically slow on large files, so to make it (allegedly 10x)
faster, do not highlight words, but rather lines.

#+BEGIN_SRC emacs-lisp
(setq flycheck-highlighting-mode 'lines)
#+END_SRC

Argh, by default flycheck and other tools are so aggressive and distracting
with all the text underlines and other annoying things.

#+BEGIN_SRC example
(set-face-attribute 'flycheck-info nil :underline nil)
(set-face-attribute 'flycheck-warning nil :underline nil)
(set-face-attribute 'flycheck-error nil :underline nil)
#+END_SRC

It is not 1970s and we don't use computer terminals with 80x24 characters
resolution anymore. Line length of 120 characters is reasonable enough.

#+BEGIN_SRC emacs-lisp
(setq-default flycheck-flake8-maximum-line-length 120)
#+END_SRC

TODO from below this point, the flycheck configuration is python-specific

Flycheck allows to run only one checker at the time. However, it allows to
chain then and run them sequentially. In this case, after running flake8,
run also a pylint.

#+BEGIN_SRC emacs-lisp
(flycheck-add-next-checker 'python-flake8 'python-pylint)
#+END_SRC

We would like to see symbolic, human readable IDs like ~no-name-in-module~
instead of numeric values like ~E0611~. However, columns width in
~M-x flycheck-list-errors~ are fixed and hardcoded, so just use numbers.

#+BEGIN_SRC emacs-lisp
(setq-default flycheck-pylint-use-symbolic-id nil)
#+END_SRC

Define a function to convert numeric error ID to symbolic.

#+BEGIN_SRC emacs-lisp
(defun pylint-id-to-symbolic (msg-id)
  (let* ((cmd (list "pylint" "--help-msg" msg-id))
         (msg (shell-command-to-string (combine-and-quote-strings cmd)))
         (start (+ (string-match ":" msg) 1))
         (end (string-match ":" msg start))
         (name (substring msg start end)))
    (car (split-string name " "))))
#+END_SRC

We can now disable false positive errors with a symbolic ID

#+BEGIN_SRC emacs-lisp
(defun pylint-disable-warning (msg-id)
  (end-of-line)
  (insert "  " (format "# pylint: disable=%s" msg-id)))
#+END_SRC

Get pylint error ID for the current line

TODO it would be better to have universal ~pylint-error-on-line~ so it easier
to test and then specify line number in ~pylint-disable-current-warning~.

#+BEGIN_SRC emacs-lisp
(defun pylint-current-error ()
  (first (flycheck-overlay-errors-at (point))))
#+END_SRC

Glue everything together in one function to disable pylint warning
for the current line.

See https://www.reddit.com/r/emacs/comments/g31gtn/generate_comment_to_disable_falsepositive_pylint/

#+BEGIN_SRC emacs-lisp
(defun pylint-disable-current-warning ()
  (interactive)
  (pylint-disable-warning
    (pylint-id-to-symbolic
      (flycheck-error-id
        (pylint-current-error)))))
#+END_SRC

** Snippets

It is so boring to type the same things again and again and again,
every day, hundred times a day. I've written the line
~import ipdb; ipdb.set_trace()~ literaly a ten thousand times in my life.
Let's install ~yasnippet~ so we can do just ~ipdb<TAB>~.

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :init
  (yas-global-mode 1))
#+END_SRC

#+RESULTS:

By default the snippet manager doesn't come with any snippets. Which is
good idea but we don't really want to write all snippets on our own,
it is a big maintanance overhead. Let's install some snippets collection
and then write/override whatever is needed.

#+BEGIN_SRC emacs-lisp
(use-package yasnippet-snippets
  :ensure t)
#+END_SRC

#+RESULTS:

Specify paths to snippets and reload all of them

#+BEGIN_SRC emacs-lisp
(setq yas-snippet-dirs
      (list (expand-file-name "snippets/" user-emacs-directory)
            yasnippet-snippets-dir))
(yas-reload-all)
#+END_SRC

You can find my custom snippets in ~./snippets/~ directory. When creating
a new snippet, just run ~M-x yas-new-snippet~ and then save it simply as
~:w keyname~. It will store it to an appropriate directory for the current
major mode.

See ~M-x yas-describe-tables~ for all available snippets.

** Scratch buffers

It is often useful to create a scratch buffer for any major mode

See https://codeberg.org/emacs-weirdware/scratch

#+BEGIN_SRC emacs-lisp
(use-package scratch
  :ensure t)
#+END_SRC

The most interesting command is ~C-u M-x scratch~ but I don't
generally like to use the ~C-u~ prefix.

#+BEGIN_SRC emacs-lisp
(defun frostyx/scratch-for-major-mode ()
  (interactive)
  (let ((current-prefix-arg 4)) ;; Emulate C-u
    (call-interactively 'scratch)))
#+END_SRC

** Languages
*** Org
#+BEGIN_SRC emacs-lisp
  ;; (add-hook 'after-init-hook 'org-agenda-list)
  
  (use-package org
    :straight (:type built-in)
    :bind (("C-c C-x C-j" . org-clock-goto))
    :ensure nil
    ;; :defer t
    ;; :after org
    ;; :demand t
    ;; :delight org-mode "✎"
    ;; :hook ((org-mode . prettify-symbols-mode)
    ;;        (org-mode . visual-line-mode)
    ;;        (org-mode . variable-pitch-mode))
    :bind (("C-c l"               . org-store-link)
           ;; ("C-c c"               . org-capture)
           ("C-c f"               . org-footnote-new)))

  (define-key global-map (kbd "C-c u") #'calendar)

  (setq-default org-reverse-datetree-level-formats
                '("Week №%W {%B-%Y}"))

  (setq org-capture-templates
        '(("c" "New task" entry (file "~/Org/agenda/GTD/Inbox.org")
           "* TODO %?")

          ("p" "PROGRAMMING (week's task)" entry (file+function "~/Org/agenda/PlanAhead.org"
                                                                (lambda () (org-reverse-datetree-goto-date-in-file nil :olp '("💻 Programming 👾"))))
           "* TODO %?\nSCHEDULED: %t DEADLINE: %t" :clock-in t)

          ("m" "Meeting" entry (file+function "~/Org/Meetings.org" (lambda () (org-reverse-datetree-goto-date-in-file nil :olp '("Meetings"))))
           "* Meeting for %U\nSCHEDULED: %U"
           :clock-in t
           :time-prompt t)

          ("e" "EXAMS (week's task)" entry (file+function "~/Org/agenda/PlanAhead.org" (lambda () (org-reverse-datetree-goto-date-in-file nil :olp '("📖 Exams 📖"))))
           "* TODO %?\nSCHEDULED: %t DEADLINE: %t")))

  (setq org-datetree-add-timestamp t)

  ;; Refresh org-agenda after rescheduling a task.
  (defun org-agenda-refresh ()
    "Refresh all `org-agenda' buffers."
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
        (when (derived-mode-p 'org-agenda-mode)
          (org-agenda-maybe-redo)))))
#+END_SRC

#+RESULTS:
: org-agenda-refresh

**** Initional variables
#+begin_src emacs-lisp 
  (setq
   org-ellipsis " ⤵" ;; ⤵, ᗐ, ↴, ▼, ▶, ⤵, ▾
   org-roam-v2-ack t                 ; anonying startup message
   ;; org-log-done 'time                ; I need to know when a task is done
   org-hide-leading-stars t
   org-log-into-drawer t
   org-startup-folded t
   ;; org-odd-levels-only t
   org-pretty-entities t
   org-startup-indented t
   org-adapt-indentation t
   org-hide-macro-markers t
   org-hide-block-startup nil
   ;; org-src-fontify-natively t
   org-src-tab-acts-natively t
   org-cycle-separator-lines 2
   org-startup-with-inline-images t
   org-display-remote-inline-images t
   org-src-preserve-indentation nil
   org-edit-src-content-indentation 2
   ;; org-fontify-quote-and-verse-blocks t
   org-export-with-smart-quotes t

   org-checkbox-hierarchical-statistics nil
   org-read-date-prefer-future 'time
   org-agenda-todo-ignore-scheduled 'future
   org-agenda-tags-todo-honor-ignore-options t
   org-agenda-todo-ignore-with-date t
   org-image-actual-width '(300)
   org-log-done (quote time)
   ;; Don't log the time a task was rescheduled or redeadlined.
   org-log-redeadline t ; changed
   org-log-reschedule t)
   org-todo-keyword-faces
   ;; '(
   ;;   ("TODO" :background "indian red" :foreground "white" :weight bold)
   ;;   ("NEXT" :background "sky blue" :foreground "black" :weight bold)
   ;;   ("WAIT" :background "olive drab" :foreground "black" :weight bold)
   ;;   ("DONE" :background "pale green" :foreground "black" :weight bold)
   ;;   ("CNCL" :background "dark red" :foreground "white" :weight bold))
  ;; org-todo-keywords
  ;; '((sequence "NEXT(n)" "TODO(t)" "WAIT(w)" "|" "DONE(d)" "CNCL(c)")) ; changed

  ;; ("DOING" :background "tomato" :foreground "white" :weight bold)
  ;; ("STOPPED" :background "firebrick2" :foreground "white" :weight bold)
  ;; ("REVIEW" :background "cyan" :foreground "black" :weight bold)
  ;; ("ARCHIVED" :background "light slate blue" :foreground "white" :weight bold)
  ;; (setq )

  ;; (setq )

  ;; (set-face-attribute 'org-table nil :inherit 'fixed-pitch)
  (with-eval-after-load 'org
    (setq org-confirm-babel-evaluate nil)
    (require 'org-tempo)

    (add-hook 'org-babel-after-execute-hook (lambda ()
                                              (when org-inline-image-overlays
                                                (org-redisplay-inline-images))))
    (add-to-list 'org-modules 'org-tempo t))
#+end_src

#+RESULTS:
| org-habit | ol-doi | ol-w3m | ol-bbdb | ol-bibtex | ol-docview | ol-gnus | ol-info | ol-irc | ol-mhe | ol-rmail | ol-eww | org-tempo |

**** Custom clock budget by day
***** For org-mode
#+begin_src emacs-lisp :lexical no
  (defun org-dblock-write:time-requirements (params)
    "Generate a table showing daily time requirements and progress for categories."
    (let* ((day-of-week (upcase (format-time-string "%^a")))
           (required-property (concat "REQUIRED_TIME_" day-of-week))
           (categories '("EGE" "MERITRANK" "CODING"))
           (today-start (format-time-string "%Y-%m-%d"))
           (today-end (format-time-string "%Y-%m-%d" (time-add (current-time) 86400))))
      
      ;; Создаем заголовок таблицы с фиксированной шириной столбцов
      (insert "| Category   | Required | Actual  | Progress  |\n")
      (insert "|------------+----------+---------+-----------|\n")
      
      (dolist (category categories)
        (let ((required 0.0)
              (actual 0.0))
          ;; Находим требуемое время
          (org-map-entries
           (lambda ()
             (let* ((cat (org-entry-get (point) "CATEGORY"))
                    (req (org-entry-get (point) required-property)))
               (when (and req (string= cat category))
                 (setq required (string-to-number req)))))
           nil 'file)
          
          ;; Вычисляем фактическое время
          (setq actual (/ (float (org-clock-sum today-start today-end
                                               (lambda () 
                                                 (string= (org-entry-get nil "CATEGORY") 
                                                        category))))
                         60.0))
          
          ;; Вычисляем прогресс
          (let ((progress (if (> required 0.0)
                            (* 100.0 (/ actual required))
                          0.0)))
            ;; Используем фиксированную ширину для каждого столбца
            (insert (format "| %-10s | %8.1f | %7.1f | %8.1f%% |\n"
                           category required actual progress)))))
      
      ;; Добавляем нижний разделитель
      (insert "|------------+----------+---------+-----------|")))
#+end_src

#+RESULTS:
: org-dblock-write:time-requirements

#+begin_src emacs-lisp :lexical no

  ;; Добавляем новый view в org-agenda-custom-commands
  (setq org-agenda-custom-commands
        (append org-agenda-custom-commands
                '()))
#+end_src

***** For org-agenda
#+begin_src emacs-lisp :lexical no
  (defun my/time-tracking-view (&optional arg)
    "Create a dedicated time tracking view with colorful styling."
    (let* ((day-of-week (upcase (format-time-string "%^a")))
           (required-property (concat "REQUIRED_TIME_" day-of-week))
           (categories '("EGE" "MERITRANK" "CODING" "PERSONAL"))
           (main-categories '("EGE" "MERITRANK" "CODING"))
           (today-start (format-time-string "%Y-%m-%d"))
           (today-end (format-time-string "%Y-%m-%d" (time-add (current-time) 86400))))

      ;; Очищаем буфер и устанавливаем заголовок
      (org-agenda-prepare "Time Tracking")
      
      ;; Красочный разделитель
      (insert 
       (propertize "============================\n" 
                   'face '(:foreground "#4A90E2")))
      
      ;; Заголовок с цветом и стилем
      (insert 
       (propertize "🕰️ TIME TRACKING DASHBOARD 🕰️\n" 
                   'face '(:foreground "#4A90E2" 
                           :weight bold 
                           :height 1.2)))
      
      ;; Дата с цветовым оформлением
      (insert 
       (propertize (format-time-string "📅 Date: %Y-%m-%d\n\n")
                   'face '(:foreground "#2196F3")))
      
      (let ((total-time 0.0)
            (category-data '())
            (most-active-cat nil)
            (most-active-hours 0.0)
            (total-tasks 0)
            (total-required 0.0))

        ;; Собираем данные по каждой категории
        (dolist (category categories)
          (let ((required 0.0)
                (actual 0.0)
                (tasks 0))

            ;; Находим требуемое время (кроме PERSONAL)
            (unless (string= category "PERSONAL")
              (org-map-entries
               (lambda ()
                 (let* ((cat (org-entry-get (point) "CATEGORY"))
                        (req (org-entry-get (point) required-property)))
                   (when (and req (string= cat category))
                     (setq required (+ required (string-to-number req))))))
               nil 'agenda))

            ;; Вычисляем фактическое время и считаем задачи
            (dolist (file (org-agenda-files))
              (with-current-buffer (org-get-agenda-file-buffer file)
                (org-clock-sum today-start today-end
                               (lambda ()
                                 (string= (org-entry-get nil "CATEGORY")
                                          category)))
                (setq actual (+ actual (/ (float org-clock-file-total-minutes) 60.0)))

                ;; Подсчёт задач (кроме PERSONAL)
                (unless (string= category "PERSONAL")
                  (org-map-entries
                   (lambda ()
                     (when (string= (org-entry-get nil "CATEGORY") category)
                       (setq tasks (1+ tasks))))
                   nil 'file))))

            ;; Обновляем статистику только для основных категорий
            (unless (string= category "PERSONAL")
              (when (> actual most-active-hours)
                (setq most-active-cat category
                      most-active-hours actual))
              (setq total-time (+ total-time actual))
              (setq total-tasks (+ total-tasks tasks))
              (setq total-required (+ total-required required)))

            (push (list category actual required tasks) category-data)))

        ;; Заголовок категорий с цветом
        (insert 
         (propertize "📊 Time Breakdown\n" 
                     'face '(:foreground "#2196F3" 
                             :weight bold)))
        
        ;; Основная таблица с цветным оформлением
        (insert "| Category   | Required | Actual  | Progress  |\n")
        (insert "|------------+----------+---------+-----------|\n")

        (dolist (data (nreverse category-data))
          (let* ((category (nth 0 data))
                 (actual (nth 1 data))
                 (required (nth 2 data)))
            (if (string= category "PERSONAL")
                (insert (format "| %-10s | %8s | %7.1f | %9s |\n"
                                category "---" actual "---"))
              (let ((progress (if (> required 0.0)
                                  (* 100.0 (/ actual required))
                                0.0))
                    (cat-color 
                     (cond 
                      ((string= category "EGE") "#FF6B6B")
                      ((string= category "MERITRANK") "#4CAF50")
                      ((string= category "CODING") "#2196F3")
                      (t "#333333"))))
                (insert 
                 (format "| %s | %8.1f | %7.1f | %8.1f%% |\n"
                         (propertize (format "%-10s" category)
                                     'face `(:foreground ,cat-color 
                                             :weight bold))
                         required actual progress))))))

        ;; График бюджета времени
        (insert "\n")
        (insert 
         (propertize "📅 Time Budget Graph\n" 
                     'face '(:foreground "#2196F3" 
                             :weight bold)))
        
        (insert (save-window-excursion
                  (with-temp-buffer
                    (org-clock-budget-report)
                    (buffer-string))))

        ;; Расширенная статистика
        (insert "\n")
        (insert 
         (propertize "📈 Productivity Statistics\n" 
                     'face '(:foreground "#2196F3" 
                             :weight bold)))
        
        ;; Статистика с цветовым оформлением
        (when most-active-cat
          (insert 
           (propertize (format "🏆 Most productive category: %s (%.1f hours)\n" 
                               most-active-cat most-active-hours)
                       'face '(:foreground "#4CAF50"))))
        
        (when (> total-tasks 0)
          (insert 
           (propertize (format "⏱️ Average time per task: %.1f minutes\n"
                               (/ (* total-time 60) total-tasks))
                       'face '(:foreground "#FF9800"))))

        ;; Общий прогресс с цветовым оформлением
        (let ((total-progress (if (> total-required 0)
                                  (* 100.0 (/ total-time total-required))
                                0)))
          (insert 
           (propertize (format "📊 Overall progress: %.1f%% (%.1f/%.1f hours)\n" 
                               total-progress total-time total-required)
                       'face `(:foreground 
                               ,(cond 
                                 ((>= total-progress 80) "#4CAF50")
                                 ((>= total-progress 50) "#FF9800")
                                 (t "#FF5722")))))))))
#+end_src

#+RESULTS:
: my/time-tracking-view

**** Org-agenda
:LOGBOOK:
CLOCK: [2024-11-14 Чт 15:29]--[2024-11-14 Чт 15:29] =>  0:00
CLOCK: [2024-11-14 Чт 15:12]--[2024-11-14 Чт 15:23] =>  0:11
CLOCK: [2024-11-14 Чт 15:12]--[2024-11-14 Чт 15:12] =>  0:00
CLOCK: [2024-11-14 Чт 15:12]--[2024-11-14 Чт 15:12] =>  0:00
CLOCK: [2024-11-14 Чт 15:11]--[2024-11-14 Чт 15:11] =>  0:00
:END:
#+begin_src emacs-lisp :lexical no
  (evil-leader/set-key
          "z" '(org-agenda nil "z")
          "qs" 'hq-shop
          "qb" 'hq-buy-item
          "qu" 'hq-use-item)

  (global-set-key (kbd "C-c C-x o") 'org-clock-out)
  (global-set-key (kbd "C-c C-x j") 'org-clock-go-to)
#+end_src

#+RESULTS:
: org-clock-go-to

#+begin_src emacs-lisp 
  (use-package org-agenda
    :ensure nil
    :straight (:type built-in)
    :bind
    (:map global-map
          ("C-c a" . org-agenda))
    :config
    (setq org-agenda-start-on-weekday 0
          org-agenda-skip-scheduled-if-done t ; changed
          org-agenda-skip-deadline-if-done t ; changed
          org-agenda-include-deadlines t
          org-agenda-block-separator #x2501
          org-agenda-compact-blocks t ; changed
          org-agenda-start-with-log-mode nil
         	org-agenda-deadline-faces
          '((1.0001 . org-warning)              ; due yesterday or before
            (0.0    . org-upcoming-deadline))   ; due today or later
         	org-icalendar-combined-name "Hugo Org"
         	org-icalendar-use-scheduled '(todo-start event-if-todo event-if-not-todo)
         	org-icalendar-use-deadline '(todo-due event-if-todo event-if-not-todo)
         	org-icalendar-timezone "Asia/Vladivostok"
         	org-icalendar-store-UID t
         	org-icalendar-alarm-time 30
         	calendar-date-style 'european
         	calendar-week-start-day 0
          calendar-mark-holidays-flag t
          calendar-mark-diary-entries-flag nil
       		;; (setq-default org-icalendar-include-todo t)
         	org-agenda-breadcrumbs-separator " ❱ "
          org-agenda-current-time-string "⏰ ┈┈┈┈┈┈┈┈┈┈┈ now"
          org-agenda-time-grid '((today require-timed remove-match)
                                 (500 800 1000 1200 1400 1600 1800 2000)
                                 ":  " "┈┈┈┈┈┈┈┈┈┈┈┈┈")
          org-agenda-prefix-format
       		'((agenda . "%-10c | %?-12t% s")
       			(todo . "%-10s")
       			(tags . "%t %-10c | %s")
       			(search . "%c %t %s"))
          org-agenda-clockreport-parameter-plist
          (quote (:maxlevel 5 :compact t :wstart 0 :link nil :formula % :tags nil :properties ("CATEGORY" "EFFORT" "File") :narrow 80 :fileskip0 t))
          org-agenda-scheduled-leaders '("[S]:" "[S] x%3dd.:")
          org-agenda-deadline-leaders '("[D]:" "[D] +%3dd.:" "[D] -%3dd.:")
         	org-agenda-format-date (lambda (date) (concat "\n" (make-string (window-width) 9472)
                                                        "\n"
                                                        (org-agenda-format-date-aligned date)))
         	org-default-notes-file "~/Org/agenda/Notes.org"
         	org-agenda-files '("~/Org/agenda/GTD/org-gtd-tasks.org")) ;; "~/Org/agenda/Calendar.org"

    (setq mixed-pitch-fixed-pitch-faces
     			(quote (line-number-current-line line-number font-lock-comment-face org-done org-todo org-todo-keyword-outd org-todo-keyword-kill org-todo-keyword-wait org-todo-keyword-done org-todo-keyword-habt org-todo-keyword-todo org-tag org-ref-cite-face org-property-value org-special-keyword org-date diff-added org-drawer diff-context diff-file-header diff-function diff-header diff-hunk-header diff-removed font-latex-math-face font-latex-sedate-face font-latex-warning-face font-latex-sectioning-5-face font-lock-builtin-face font-lock-comment-delimiter-face font-lock-constant-face font-lock-doc-face font-lock-function-name-face font-lock-keyword-face font-lock-negation-char-face font-lock-preprocessor-face font-lock-regexp-grouping-backslash font-lock-regexp-grouping-construct font-lock-string-face font-lock-type-face font-lock-variable-name-face markdown-code-face markdown-gfm-checkbox-face markdown-inline-code-face markdown-language-info-face markdown-language-keyword-face markdown-math-face message-header-name message-header-to message-header-cc message-header-newsgroups message-header-xheader message-header-subject message-header-other mu4e-header-key-face mu4e-header-value-face mu4e-link-face mu4e-contact-face mu4e-compose-separator-face mu4e-compose-header-face org-block org-block-begin-line org-block-end-line org-document-info-keyword org-code org-indent org-latex-and-related org-checkbox org-formula org-meta-line org-table org-verbatim)))

    ;; Hide duplicates of the same todo item
    ;; If it has more than one of timestamp, scheduled,
    ;; or deadline information
    (setq org-agenda-skip-timestamp-if-done t
     			org-agenda-skip-deadline-if-done t
     			org-agenda-skip-scheduled-if-done t
     			org-agenda-skip-scheduled-if-deadline-is-shown t
     			org-agenda-skip-timestamp-if-deadline-is-shown t)

    ;; (setq org-agenda-clockreport-parameter-plist
    ;;       (quote (:link t :maxlevel 5 :fileskip t :compact t :narrow 80)))

    (defun my/style-org-agenda()
      (set-face-attribute 'org-agenda-date nil :height 1.3)
      (set-face-attribute 'org-agenda-date-today nil :height 1.3 :slant 'italic)
      (set-face-attribute 'org-agenda-date-weekend nil :height 1.3))
    (add-hook 'org-agenda-mode-hook 'my/style-org-agenda)

    (setq org-agenda-custom-commands
          '(("c" "Getting Things Done (GTD)"
             ((agenda "" ((org-agenda-span 'day)
   												(org-agenda-skip-scheduled-if-done nil)
   												(org-agenda-skip-deadline-if-done nil)
   												(org-agenda-clockreport-mode t)
   												(org-agenda-remove-tags t)
   												(org-agenda-sorting-strategy '(habit-down time-up priority-down category-keep user-defined-up))
   												(org-time-budgets-in-agenda-maybe)
   												(org-agenda-include-deadlines t)

   												(org-agenda-files '("~/Org/agenda/PlanAhead.org" "~/Org/agenda/GTD/org-gtd-tasks.org"))
   												(org-super-agenda-groups
   												 '((:name "Schedule"
         														:time-grid t)
   													 (:name "Today"
         														:scheduled today
         														:face (:background "medium sea green" :foreground "white")
   																	:face 'warning)
   													 (:name "Future deadline"
         														:deadline future
         														:face (:background "deep sky blue"))
   													 (:name "Deadline today"
         														:deadline today
         														:face (:background "black" :foreground "white"))
   													 (:name "Passed deadline"
         														:deadline past
   																	:scheduled past
         														:face (:background "salmon"))))))

   						(tags "CLOSED>=\"<today>\""
   									((org-agenda-overriding-header "\nCompleted today\n")))
              
              (gtd-add-progress-info-to-agenda "")))
            
            ("x" "Habits view"
             ((agenda "" ((org-agenda-span 'day)
                          (org-habit-show-habits t)
                          (org-agenda-remove-tags t)
                          (org-agenda-prefix-format "  ∘ %t %s")
                          (org-agenda-files '("~/Org/agenda/GTD/org-gtd-tasks.org"))
                          (org-agenda-finalize-hook '(hq-add-quest-info-to-agenda))
                          (org-super-agenda-groups
                           '((:name "Everytime"
         														:tag ("everytime"))
         										 (:name "Morning"
         													  :tag ("morning"))
         										 (:name "Day"
         													  :tag ("day"))
         										 (:name "Evening"
         													  :tag ("evening"))
         										 ;; (:name "Challenges"
         										 ;;  			:tag "challenge")
         										 (:discard (:anything))
         										 (:discard (:not (:tag "habit")))))))
              (hq-add-quest-info-to-agenda "")))
            
            ("p" "Private counter"
             ((agenda "" ((org-agenda-span 'day)
                          (org-habit-show-habits t)
                          (org-agenda-remove-tags t)
                          (org-agenda-prefix-format "  ∘ %t %s")
                          (org-agenda-files '("~/Org/agenda/GTD/org-gtd-tasks.org"))
                          (org-super-agenda-groups
                           '((:name "===== Other ====="
         												    :tag "other"
                                    :face (:background "red" :foreground "white" :weight "bold"))
         										 (:discard (:anything))
         										 (:discard (:not (:tag "habit")))))))))

     				;; ("k" "Time Tracking Overview"
            ;;  my/time-tracking-view)

            ("d" "Day results"
             ((agenda ""
                      ((org-agenda-span 'day)
   										 (org-agenda-overriding-header "\n === TIME REPORT ===")
   										 (org-agenda-skip-scheduled-if-done nil)
   										 (org-log-done 'time)
   										 (org-log-into-drawer nil)
   										 (org-agenda-skip-deadline-if-done nil)
   										 ;;(org-agenda-block-separator nil)
   										 (org-agenda-clockreport-mode t)
   										 (org-agenda-remove-tags t)
   										 (org-agenda-sorting-strategy '(habit-down time-up priority-down category-keep user-defined-up))
   										 (org-time-budgets-in-agenda-maybe)
   										 (org-agenda-include-deadlines t)
   										 (org-agenda-clockreport-parameter-plist
   											'(:scope ("~/Org/agenda/GTD/org-gtd-tasks.org"
   																"~/Org/agenda/GTD/gtd_archive_2025"
   																"~/Org/agenda/GTD/gtd_archive_2024"
   																"~/Org/agenda/GTD/org-gtd-tasks.org_archive")
   															 :maxlevel 5
   															 :emphasize t
   															 :block day
   															 :compact t
   															 :wstart 0
   															 :link nil
   															 :formula %
   															 :tags nil
  															 :hidefiles t
   															 :properties ("CATEGORY" "EFFORT")))
   										 (org-agenda-files '("~/Org/agenda/GTD/org-gtd-tasks.org"
   																				 "~/Org/agenda/GTD/gtd_archive_2025"
   																				 "~/Org/agenda/GTD/gtd_archive_2024"
   																				 "~/Org/agenda/GTD/org-gtd-tasks.org_archive"))
   										 (org-super-agenda-groups '((:discard (:anything))))))
   						(my/time-tracking-view "")
   						(tags "CLOSED>=\"<today>\""
   									((org-agenda-overriding-header "\n === COMPLETED TASKS ===")
   									 (org-agenda-remove-tags t)))))))

    (add-hook 'org-agenda-mode-hook 'org-super-agenda-mode))
#+end_src

#+RESULTS:
: org-agenda

**** Org-habit
#+begin_src emacs-lisp
  (use-package org-habit
    :after org
    :ensure nil
    :straight (:type built-in)
    :init
    ;;(add-to-list 'org-modules 'org-habit)
    (progn
      (custom-set-faces
       '(org-habit-clear-face
         ((t (:background "pale green"
          								:foreground "white"
          								:width expanded
          								:height 1.0
          								:box (:line-width (1 . 1) :color "white")))))

       '(org-habit-clear-future-face
         ((t (:background "gray"
          								:foreground "white"
          								:width expanded
          								:height 1.0
          								:box (:line-width (1 . 1) :color "white")))))
       '(org-habit-alert-future-face
         ((t (:background "light coral"
          								:foreground "white"
          								:width expanded
          								:height 1.0
          								:box (:line-width (1 . 1) :color "white")))))
       '(org-habit-alert-face
         ((t (:background "light coral"
          								:foreground "white"
          								:width expanded
          								:height 1.0
          								:box (:line-width (1 . 1) :color "white")))))
       '(org-habit-overdue-face
         ((t (:background "light coral"
          								:foreground "white"
          								:width expanded
          								:height 1.0
          								:box (:line-width (1 . 1) :color "white")))))
       '(org-habit-overdue-future-face
         ((t (:background "gray"
          								:foreground "white"
          								:width expanded
          								:height 1.0
          								:box (:line-width (1 . 1) :color "white")))))
       '(org-habit-ready-face
         ((t (:background "pale green"
          								:foreground "white"
          								:width expanded
          								:height 1.0
          								:box (:line-width (1 . 1) :color "white")))))
       '(org-habit-ready-future-face
         ((t (:background "gray"
          								:foreground "white"
          								:width expanded
          								:height 1.0
          								:box (:line-width (1 . 1) :color "white")))))
       ))
    :config
    (load "~/.emacs.d/lisp/my-org-habit")
    (setq org-habit-following-days 1
          org-habit-preceding-days 9
          org-habit-show-habits nil
          org-habit-show-all-today t
          org-habit-graph-column 60
          org-habit-overdue-glyph ?○
          org-habit-alert-glyph ?○
          org-habit-ready-future-glyph ?○ ;;⬡
          org-habit-today-glyph ?◎
          org-habit-completed-glyph ?●
          org-habit-show-done-always-green t)

    (defun toggle-org-habit-show-all-today ()
      "Toggle the value of `org-habit-show-all-today' between t and nil."
      (interactive)
      (setq org-habit-show-all-today (not org-habit-show-all-today))
      (message "org-habit-show-all-today is now %s"
          		 (if org-habit-show-all-today "nil" "t"))
      (org-agenda-refresh))

    (define-key org-agenda-mode-map (kbd "<f12>") 'toggle-org-habit-show-all-today))

  (use-package org-habit-stats
    :ensure t
    :config
    (add-hook 'org-after-todo-state-change-hook 'org-habit-stats-update-properties)
    (add-hook 'org-agenda-mode-hook
          		(lambda () (define-key org-agenda-mode-map "Z" 'org-habit-stats-view-next-habit-in-agenda))))

(defun org-habit-count-last-streak (state-str)
  "Подсчитывает количество последних подряд идущих ● в строке состояния."
  (let ((streak 0))
    (cl-loop for i from (1- (length state-str)) downto 0
             while (= (aref state-str i) ?●)
             do (setq streak (1+ streak)))
    streak))

(defun org-habit-streak-count ()
  "Подсчитывает и отображает текущий стрик для каждой привычки в org-agenda."
  (goto-char (point-min))
  (while (not (eobp))
    (when (get-text-property (point) 'org-habit-p)
      (let ((streak 0))
        ;; Ищем строку состояния привычки (○●◎)
        (save-excursion
          (when (re-search-forward "\\([○●◎]\\)+" (line-end-position) t)
            (let ((state-str (match-string 0)))
              ;; Если последний символ ●, считаем стрик
              (when (= (aref state-str (1- (length state-str))) ?●)
                (setq streak (org-habit-count-last-streak state-str))))))
        
        (end-of-line)
        (insert (format " [🔥 %d]" streak))))
    (forward-line 1)))

(add-hook 'org-agenda-finalize-hook 'org-habit-streak-count)
#+end_src

#+RESULTS:
| org-habit-streak-count |

**** Org gamifications
#+begin_src emacs-lisp :lexical no
  (load "~/.emacs.d/lisp/gamifications/quest-system-core")
  (load "~/.emacs.d/lisp/gamifications/market")
  (load "~/.emacs.d/lisp/gamifications/habit-quest")
  (load "~/.emacs.d/lisp/gamifications/tasks-quest")
#+end_src

#+RESULTS:
: t

**** Insert org-agenda
#+begin_src emacs-lisp :lexical no
  (defun my/insert-daily-reports ()
    "Вставить отчеты habits и day results в текущий буфер с измененными параметрами отображения."
    (interactive)
    (let ((original-habit-column org-habit-graph-column))
      (setq org-habit-graph-column 38)
      (let* ((habits-report (save-window-excursion
                             (with-temp-buffer
                               (org-agenda nil "x")
                               (buffer-string))))
             (day-results (save-window-excursion
                           (with-temp-buffer 
                             (org-agenda nil "d")
                             (buffer-string))))
             ;; Удаляем разделители из обоих отчетов
             (habits-clean (replace-regexp-in-string "^─+\n" "" habits-report))
             (day-clean (replace-regexp-in-string "^─+\n" "" day-results)))
        (setq org-habit-graph-column original-habit-column)
        (insert "** Habits report" habits-clean "\n\n** Day results" day-clean))))
#+end_src

#+RESULTS:
: my/insert-daily-reports

**** Org-timeline 
#+begin_src example :lexical no
  (use-package org-timeline
  	:ensure t
  	:config
  	(add-hook 'org-agenda-finalize-hook 'org-timeline-insert-timeline :append))
#+end_src

#+RESULTS:
: t

**** Bibliography
***** Org ref
#+begin_src emacs-lisp :lexical no
  (use-package org-ref
  	:quelpa (org-ref
         :fetcher github
         :repo "jkitchin/org-ref"
         :branch "master")
  	;;:ensure t
    :config
  	;;(require 'org-ref)
  	;;(require 'org-ref-helm)
  	(define-key org-mode-map (kbd "C-c ]") 'org-ref-insert-link)

  	(setq bibtex-completion-bibliography '("~/Org/Bibliography/Bibliography.bib")
  				bibtex-completion-library-path '("~/Org/Bibliography/files/")
  				bibtex-completion-notes-path "~/Org/Bibliography/notes/"
  				bibtex-completion-notes-template-multiple-files "* ${author-or-editor}, ${title}, ${journal}, (${year}) :${=type=}: \n\nSee [[cite:&${=key=}]]\n"

  				bibtex-completion-additional-search-fields '(keywords)
  				bibtex-completion-display-formats
  				'((article       . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*} ${journal:40}")
  					(inbook        . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*} Chapter ${chapter:32}")
  					(incollection  . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*} ${booktitle:40}")
  					(inproceedings . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*} ${booktitle:40}")
  					(t             . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*}"))
  				bibtex-completion-pdf-open-function
  				(lambda (fpath)
  					(call-process "open" nil 0 nil fpath)))
  	(setq bibtex-autokey-year-length 4
  				bibtex-autokey-name-year-separator "-"
  				bibtex-autokey-year-title-separator "-"
  				bibtex-autokey-titleword-separator "-"
  				bibtex-autokey-titlewords 2
  				bibtex-autokey-titlewords-stretch 1
  				bibtex-autokey-titleword-length 5))
#+end_src

#+RESULTS:
: t

Херня. не надо использовать
#+begin_src example
  ;; Определяем целевые показатели времени (в часах) на неделю для каждой категории
  (setq my-weekly-targets
        '(("SLEEP" . 52.5)
          ("BASIC" . 24.5)
          ("MERITRANK" . 35.0)
          ("CODING" . 21.0)
          ("EGE" . 14.0)
          ("SPORT" . 10.5)
          ("BUFFER" . 10.5)))

  ;; Функция для получения времени, затраченного на категорию за текущую неделю
  (defun get-category-time-this-week (category)
    "Get total clocked time for CATEGORY in the current week."
    (let* ((today (current-time))
           (week-start (time-subtract today
                                    (seconds-to-time
                                     (* 3600 24 (nth 6 (decode-time today))))))
           (total 0.0))
      (org-map-entries
       (lambda ()
         (when (string= category (org-get-category))
           (setq total (+ total (org-clock-sum
                                (format-time-string "%Y-%m-%d" week-start)
                                (format-time-string "%Y-%m-%d" today))))))
       nil 'agenda)
      (/ total 3600.0)))

  (defun create-time-tracking-report ()
    "Create a report table showing planned vs actual time for categories."
    (interactive)
    (with-current-buffer (get-buffer-create "*Time Tracking Report*")
      (erase-buffer)
      (org-mode)
      (insert "#+TITLE: Weekly Time Tracking Report\n\n")
      (insert "| Category | Target (h) | Actual (h) | Target % | Actual % | Diff % |\n")
      (insert "|----------+------------+------------+----------+-----------+--------|\n")
      (let ((total-target 168.0)
            (total-actual 0.0))
        (dolist (target my-weekly-targets)
          (let* ((category (car target))
                 (target-hours (cdr target))
                 (actual-hours (get-category-time-this-week category))
                 (target-percent (round (* 100.0 (/ target-hours total-target))))
                 (actual-percent (round (* 100.0 (/ actual-hours total-target))))
                 (diff-percent (- actual-percent target-percent)))
            (setq total-actual (+ total-actual actual-hours))
            (insert (format "| %s | %.1f | %.1f | %d | %d | %d |\n"
                           category
                           target-hours
                           actual-hours
                           target-percent
                           actual-percent
                           diff-percent))))
        (insert "|----------+------------+------------+----------+-----------+--------|\n")
        (insert (format "| Total | %.1f | %.1f | %d | %d | %d |\n"
                       total-target
                       total-actual
                       100
                       (round (* 100.0 (/ total-actual total-target)))
                       (- (round (* 100.0 (/ total-actual total-target))) 100))))
      (org-table-align)
      (display-buffer (current-buffer))))

  ;; Функция для создания таблицы с отчётом
  (defun create-time-tracking-report ()
    "Create a report table showing planned vs actual time for categories."
    (interactive)
    (with-current-buffer (get-buffer-create "*Time Tracking Report*")
      (erase-buffer)
      (org-mode)
      (insert "#+TITLE: Weekly Time Tracking Report\n\n")
      (insert "| Category | Target (h) | Actual (h) | Target % | Actual % | Diff % |\n")
      (insert "|----------+------------+------------+----------+-----------+--------|\n")
      (let ((total-target 168.0)
            (total-actual 0))
        (dolist (target my-weekly-targets)
          (let* ((category (car target))
                 (target-hours (cdr target))
                 (actual-hours (get-category-time-this-week category))
                 (target-percent (* 100 (/ target-hours total-target)))
                 (actual-percent (* 100 (/ actual-hours total-target)))
                 (diff-percent (- actual-percent target-percent)))
            (setq total-actual (+ total-actual actual-hours))
            (insert (format "| %s | %.1f | %.1f | %.1f | %.1f | %.1f |\n"
                           category
                           target-hours
                           actual-hours
                           target-percent
                           actual-percent
                           diff-percent))))
        (insert "|----------+------------+------------+----------+-----------+--------|\n")
        (insert (format "| Total | %.1f | %.1f | 100.0 | %.1f | %.1f |\n"
                       total-target
                       total-actual
                       (* 100 (/ total-actual total-target))
                       (- (* 100 (/ total-actual total-target)) 100))))
      (org-table-align)
      (display-buffer (current-buffer))))

  ;; Добавляем hook для автоматического обновления отчёта при clock-out
  (add-hook 'org-clock-out-hook 'create-time-tracking-report)

  ;; Создаём удобную клавиатурную комбинацию для вызова отчёта
  (global-set-key (kbd "C-c C-x r") 'create-time-tracking-report)
#+end_src

#+RESULTS:
: create-time-tracking-report

***** Org roam bibtex 
#+begin_src emacs-lisp :lexical no :async
  (use-package org-roam-bibtex
    :after org-roam
  	:quelpa (org-roam-bibtex
         :fetcher github
         :repo "org-roam/org-roam-bibtex"
         :branch "main"))
    ;;:config
    ;;(require 'org-ref) ; optional: if using Org-ref v2 or v3 citation links
#+end_src

#+begin_src emacs-lisp :lexical no
  (defun my-org-zotero-open (path _)
    (call-process "xdg-open" nil nil nil (concat "zotero:" path)))

  (org-link-set-parameters "zotero" :follow 'my-org-zotero-open)
#+end_src

#+RESULTS:
| :follow | my-org-zotero-open |

***** Citar
#+begin_src emacs-lisp :lexical no :async
  (use-package citar
  	:quelpa (citar
         :fetcher github
         :repo "emacs-citar/citar"
         :branch "main")
    :no-require
    :custom
    (org-cite-global-bibliography '("~/Org/Bibliography/Bibliography.bib"))
    (org-cite-insert-processor 'citar)
    (org-cite-follow-processor 'citar)
    (org-cite-activate-processor 'citar)
    (citar-bibliography org-cite-global-bibliography)
    ;; optional: org-cite-insert is also bound to C-c C-x C-@
    :bind
    (:map org-mode-map :package org ("C-c b" . #'org-cite-insert))
    :config
    (defvar citar-indicator-notes-icons
  		(citar-indicator-create
  		 :symbol (all-the-icons-material
  							"speaker_notes"
  							:face 'all-the-icons-blue
  							:v-adjust -0.3)
  		 :function #'citar-has-notes
  		 :padding "  "
  		 :tag "has:notes")))
#+end_src

#+RESULTS:
: org-cite-insert

#+begin_src example :lexical no :async
  (use-package citar-embark
  	:ensure t
    :after citar embark
    :no-require
    :config (citar-embark-mode))
#+end_src

#+RESULTS:

**** Ob-lang
#+begin_src emacs-lisp :lexical no
  (use-package tsc
    :ensure t)

  (use-package ob-typescript
  	:ensure t)
  (use-package ob-rust
  	:ensure t)
  (use-package ob-solidity
  	:ensure t)
  (use-package ob-sql-mode
  	:ensure t)
  (use-package ob-restclient
    :ensure t)
  (use-package gnuplot
    :ensure t)

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (js         . t)
     (solidity   . t)
     (typescript . t)
     (shell      . t)
     (python     . t)
     (rust       . t)
     (C          . t)
     (sql        . t)
     (latex      . t)
     (restclient . t)
     (gnuplot    . t)))
#+end_src

#+RESULTS:

**** Org-modern
#+begin_src emacs-lisp
    (setq org-tag-alist
          '(
    				("@article" . ?a)
            ("@personal" . ?P)
            ("@coding" . ?p)
            ("@mathematics" . ?m)
    				("@school" . ?s)
            ("@english" . ?e)
    				("@work" . ?w)
            ("@zettelkasten" . ?z)
    				("@idea" . ?i)))

    (use-package org-modern
      :hook (org-mode . org-modern-mode)
      :ensure t
      :config
      (setq
       ;; Edit settings
       org-catch-invisible-edits 'show-and-error
       org-special-ctrl-a/e t
       ;; Appearance
       org-modern-radio-target    '("❰" t "❱")
       org-modern-internal-target '("↪ " t "")
       org-modern-block-name
    	 '((t . t)
    	   ("src" "ϰ" "ϰ"))
       org-modern-progress t
       org-modern-statistics nil
       org-modern-todo t
       org-modern-todo-faces (quote (("TODO" :background "indian red" :foreground "white" :weight bold)
    																 ("NEXT" :background "sky blue" :foreground "black" :weight bold)
    																 ("WAIT" :background "olive drab" :foreground "black" :weight bold)
    																 ("DONE" :background "pale green" :foreground "black" :weight bold)
    																 ("CNCL" :background "dark red" :foreground "white" :weight bold)))
       org-modern-priority t
       org-modern-priority-faces (quote ((?A :background "red"
    																				 :foreground "black")
    																		 (?B :background "dark orange"
    																				 :foreground "black")
    																		 (?C :background "tan"
    																				 :foreground "black")))
       org-modern-tag t
       org-modern-timestamp nil
       org-modern-statistics t
       ;; org-modern-table t
       org-modern-tag-faces (quote (("@coding" :background "#d60000" :foreground "#000000")
    																("@personal" :background "#e67c73" :foreground "#000000")
    																("@article" :background "#0b8043" :foreground "#000000")
    																("@mathematics" :background "#bc8f8f" :foreground "#000000")
                                    ("blockchain" :background "#f5511d" "#000000")
    																("solana" :background "#DC1FFF" :foreground "#000000")
    																("rust" :background "#CE412B" :foreground "#000000")
    																("go" :background "#00bfff" :foreground "#00000")
    																("exams" :background "#8e24aa" :foreground "#000000")))
       org-modern-horizontal-rule "──────────────────────────────────────────────────────────────────────────────────────────"
       org-modern-hide-stars " "
       org-modern-keyword "‣"
       org-modern-table t))
  (global-org-modern-mode t)
#+end_src

#+RESULTS:
: t

**** Org-pomodoro
:LOGBOOK:
CLOCK: [2024-11-01 Пт 14:28]--[2024-11-01 Пт 14:58] =>  0:30
:END:
The Pomodoro Technique is a time management technique that uses a timer to break
work into short intervals (typically 25 minutes of work followed by 5 minutes of
rest).

See https://todoist.com/productivity-methods/pomodoro-technique
See a simple pomodoro timer in the web browser https://pomofocus.io/

Of course, we want to use Emacs and ~org-mode~.

#+begin_src emacs-lisp :lexical no
  ;;(frostyx/guix :install "alsa-utils")
    
  (use-package sound-wav
    :ensure t
    :demand t) ;; dep for org-pomodoro
#+end_src

#+RESULTS:

#+begin_src emacs-lisp :lexical no
  (use-package powershell
    :ensure t
    :demand t) ;; dep for org-pomodoro
#+end_src

#+RESULTS:

#+BEGIN_SRC emacs-lisp
  (use-package org-pomodoro
    :ensure t
  	:bind (("C-c k" . my/org-pomodoro))
  	:config
  	(setq org-pomodoro-audio-player (or (executable-find "aplay") (executable-find "afplay"))
          org-pomodoro-play-sounds t           ; Determines whether soudns are played or not
  				org-pomodoro-keep-killed-pomodoro-time t
  				org-pomodoro-format " %s"
  				org-pomodoro-short-break-format " Short Break %s"
  				org-pomodoro-long-break-format  " Long Break %s"
  				;; org-pomodoro-finished-sound-p t
          ;; org-pomodoro-start-sound "/home/vberezhnev/.emacs.d/sounds/bell.mp3"

          org-pomodoro-start-sound-p t         ; Determine whether to play a sound when a pomodoro started
          org-pomodoro-start-sound (expand-file-name "sounds/bell.wav" user-emacs-directory)
          org-pomodoro-length 40                ; The length of a pomodoro in minutes

          org-pomodoro-finished-sound-p t      ; Determines whether to play a sound when a pomodoro finished
          org-pomodoro-finished-sound (expand-file-name "sounds/bell.wav" user-emacs-directory)

          org-pomodoro-manual-break t          ; Whether the user needs to exit manually from a running pomodoro to enter a break
          org-pomodoro-overtime-sound-p t      ; Determines whether to play a sound when a pomodoro starts to run overtime
          org-pomodoro-overtime-sound (expand-file-name "sounds/bell.wav" user-emacs-directory)

  				org-pomodoro-length 40
  				org-pomodoro-short-break-length 5
  				org-pomodoro-long-break-length 15
  				org-pomodoro-long-break-frequency 3
  				;;org-pomodoro-expiry-time 30
          ;;org-pomodoro-clock-break t           ; Whether to clock time during breaks
  				))

  (defun my/org-clock-get-clock-string ()
    (concat " " org-clock-heading))

  (setq spaceline-org-clock-format-function 'my/org-clock-get-clock-string)

  ;; (set-face-attribute 'org-pomodoro-mode-line nil :foreground my/green)
  ;; (set-face-attribute 'org-pomodoro-mode-line-overtime nil :foreground my/red)
#+END_SRC

#+RESULTS:
: my/org-clock-get-clock-string

If something goes wrong, you can test the sounds with

#+BEGIN_SRC example
  (org-pomodoro-play-sound :start)
#+END_SRC

#+RESULTS:
: #s(deferred #[257 "r\211q\210\300 )\301!\210\207" [buffer-string kill-buffer] 4 "
: 
: (fn BUF)"] deferred:default-errorback #[257 "\302\300\242!\210\302\301!\207" [(#0) #s(deferred deferred:default-callback deferred:default-errorback deferred:default-cancel #0 nil nil) deferred:default-cancel] 3 "
: 
: (fn X)"] nil nil nil)

Ah, chills.

#+BEGIN_SRC example
  ;; (setq org-pomodoro-short-break-sound-p nil)
  ;; (setq org-pomodoro-long-break-sound-p nil)

  (setq org-pomodoro-length 40)
  (setq org-pomodoro-short-break-length 5)
  (setq org-pomodoro-long-break-length 15)
  (setq org-pomodoro-long-break-frequency 3)
  (setq org-pomodoro-expiry-time 30)
#+END_SRC

#+RESULTS:
: 30

#+BEGIN_SRC emacs-lisp
(defun my/org-pomodoro ()
  (interactive)
  (org-pomodoro '(4)))
#+END_SRC

#+RESULTS:
: my/org-pomodoro

**** Pomidor
#+begin_src example :lexical no
  (use-package pomidor
  	:ensure t
    :bind (("C-c C-x k" . pomidor))
    :config (setq pomidor-sound-tick nil
                  pomidor-sound-tack nil
  								pomidor-seconds (* 45 60)
  								pomidor-break-seconds (* 5 60)
  								pomidor-breaks-before-long 4
  								pomidor-long-break-seconds (* 15 60))
    :hook (pomidor-mode . (lambda ()
                            (display-line-numbers-mode -1) ; Emacs 26.1+
                            (setq left-fringe-width 0 right-fringe-width 0)
                            (setq left-margin-width 2 right-margin-width 0)
                            ;; force fringe update
                            (set-window-buffer nil (current-buffer)))))
#+end_src

#+RESULTS:
: pomidor

**** Org timed alerts
#+begin_src emacs-lisp :lexical no
  (use-package org-timed-alerts
    :straight (:host github
               :repo "legalnonsense/org-timed-alerts"
               :branch "master" :files ("*.el" "out"))
    :after (org)
    :custom
    (org-timed-alerts-alert-function #'alert)
    (org-timed-alerts-tag-exclusions nil)
    (org-timed-alerts-default-alert-props nil)
    (org-timed-alerts-warning-times '(-30 -15 -5))
    (org-timed-alerts-agenda-hook-p t)
    (org-timed-alert-final-alert-string "IT IS %alert-time\n\n%todo %headline")
    (org-timed-alert-warning-string (concat "%todo %headline\n at %alert-time"))
    :config
    (add-hook 'org-mode-hook #'org-timed-alerts-mode))
#+end_src

#+RESULTS:
: t

**** Prettify symbols
#+begin_src emacs-lisp :lexical no
  ;; ────────────────────────────── Prettify Symbols ─────────────────────────────
  ;; Beautify Org Checkbox Symbol
  (defun ma/org-buffer-setup ()
    "Something for like document, i guess 😕."
    (push '("[ ]" . "☐" ) prettify-symbols-alist)
    (push '("[X]" . "☑" ) prettify-symbols-alist)
    (push '("[-]" . "❍" ) prettify-symbols-alist))

  (setq prettify-symbols-unprettify-at-point 'right-edge)

  (add-hook 'org-mode-hook 'ma/org-buffer-setup)
  (add-hook 'org-mode-hook 'prettify-symbols-mode)
#+end_src

#+RESULTS:
| prettify-symbols-mode | #[0 \301\211\207 [imenu-create-index-function org-imenu-get-tree] 2] | org-appear-mode | toc-org-mode | org-modern-mode | org-tempo-setup | ma/org-buffer-setup | (lambda nil (set (make-local-variable 'company-backends) '(company-org-block)) (company-mode 1)) | olivetti-mode | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-fold-show-all append local] 5] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes | org-eldoc-load |

**** Org roam
#+begin_src emacs-lisp :lexical no
  (evil-leader/set-key
  	"nl" 'org-roam-buffer-toggle
  	"nf" 'org-roam-node-find
  	"ni" 'org-roam-node-insert
  	"nc" 'org-roam-capture
  	"nt" 'org-roam-tag-add
  	"nr" 'org-roam-ref-add
  	"nj" 'org-roam-dailies-capture-today
  	"ng" 'org-id-get-create
    "nb" 'orb-insert-link)
#+end_src

#+RESULTS:

#+BEGIN_SRC emacs-lisp
      (use-package sqlite3
        :ensure t)
      (use-package emacsql
        :ensure t)

      (use-package org-roam
        :ensure t
        :bind (("C-c n l" . org-roam-buffer-toggle)
               ("C-c n f" . org-roam-node-find)
               ("C-c n i" . org-roam-node-insert)
               ("C-c n c" . org-roam-capture)
               ("C-c n t" . org-roam-tag-add)
               ("C-c n r" . org-roam-ref-add)
               ("C-c g" . org-id-get-create)
               ("C-c n j" . org-roam-dailies-capture-today)
               ("C-c n b" . orb-insert-link)
               :map org-mode-map
               ("C-M-i"    . completion-at-point))
        :custom
        (org-roam-directory (file-truename "~/Org/Org-roam"))
        (org-roam-completion-everywhere t)
        (org-roam-capture-templates
         '(("a" "Atomic note (with source)" plain (file "~/Org/Templates/Atomic note.org")
            :if-new
            (file+head "%<%Y-%m-%d-%H:%M>--${slug}.org" "#+startup: latexpreview\n#+date: %U\n#+title: ${title}\n")
            :unnarrowed t)

           ("b" "Biography (Person)" plain (file "~/Org/Templates/Person.org")
            :if-new (file+head "persons/%<%Y-%m-%d-%H:%M>--person-${slug}.org" "#+title: ${title}\n#+filetags: :Biography:\n#+date: %U\n")
            :unnarrowed t)

           ("r" "Bibliography reference" plain (file "~/Org/Templates/Bibliography reference.org") ; <-- template store in a separate file
            :target
            (file+head "bibliography/references/${citekey}.org" "#+title: ${title}\n#+date: %U")
            :unnarrowed t)))

        (org-roam-capture-ref-templates
         '(("r" "ref" plain
            "%?"
            :target (file+head "web/${slug}.org"
                               "#+title: ${title}\n#+roam_key: ${ref}\n#+created: %u\n#+last_modified: %U\n\n%(zp/org-protocol-insert-selection-dwim \"%i\")")
            :unnarrowed t)
           ("i" "incremental" plain
            "* %?\n%(zp/org-protocol-insert-selection-dwim \"%i\")"
            :target (file+head "web/${slug}.org"
                               "#+title: ${title}\n#+roam_key: ${ref}\n#+created: %u\n#+last_modified: %U\n\n")
            :unnarrowed t
            :empty-lines-before 1)))

        (setq epa-file-cache-passphrase-for-symmetric-encryption t)

        (org-roam-dailies-capture-templates
            '(("d" "Дневник продуктивности - утро" plain (file "~/Org/Templates/journal/Morning.org")
              :if-new (file+head "%<%Y-%m-%d>.org" "* %U\n#+title: %U\n\n"))

              ("D" "Дневник продуктивности - вечер" plain (file "~/Org/Templates/journal/Evening.org")
              :if-new (file+head "%<%Y-%m-%d>.org" "* %U\n#+title: %U\n\n"))

              ("j" "Мысли" plain "* %U"
               :if-new (file+head "%<%Y-%m-%d>.org" "* %U\n#+title: %U\n\n"))))
        :config
        ;; Org-noter integration with org-roam-bibtex
        (setq orb-preformat-keywords
              '("title" "citekey"  "url" "author-or-editor" "keywords" "file")
              orb-process-file-keyword t)
        (setq orb-preformat-keywords
              '("citekey" "title" "url" "author-or-editor" "keywords" "file")
              orb-process-file-keyword t
              orb-attached-file-extensions '("pdf"))
        (setq org-roam-dailies-directory "journal/")
        (setq org-roam-completion-everywhere t)
        ;; (setq org-roam-database-connector 'sqlite)
        (org-roam-db-autosync-mode)
                                              ; Show +FILETAG in node list
                                              ; https://github.com/org-roam/org-roam/commit/6f5d65abd9e707b3fdb10092a9fef3b739e143dd
        (setq fill-prefix "")  ;; see https://emacs.stackexchange.com/a/38943/12999
        (setq org-roam-node-display-template
              (concat "${title:*} "
                      (propertize "${tags:60}" 'face 'org-tag)))

        ;;for org-roam-buffer-toggle
        ;;Recommendation in the official manual
        (add-to-list 'display-buffer-alist
                     '("\\*org-roam\\*"
                       (display-buffer-in-direction)
                       (direction . right)
                       (window-width . 0.33)
                       (window-height . fit-window-to-buffer)))
        )

      (use-package org-roam-timestamps
        :ensure t
        :after org-roam
        :demand t
        :config (org-roam-timestamps-mode)
        (setq org-roam-timestamps-parent-file t)
        (setq org-roam-timestamps-remember-timestamps t))

      (defun org-roam-create-note-from-headline ()
        "Create an Org-roam note from the current headline and jump to it.

              Normally, insert the headline’s title using the ’#title:’ file-level property
              and delete the Org-mode headline. However, if the current headline has a
              Org-mode properties drawer already, keep the headline and don’t insert
              ‘#+title:'. Org-roam can extract the title from both kinds of notes, but using
              ‘#+title:’ is a bit cleaner for a short note, which Org-roam encourages."
        (interactive)
        (let ((title (nth 4 (org-heading-components)))
              (has-properties (org-get-property-block)))
          (org-cut-subtree)
          (org-roam-node-find 'other-window title nil)
          (org-paste-subtree)
          (unless has-properties
            (kill-line)
            (while (outline-next-heading)
              (org-promote)))
          (goto-char (point-min))
          (when has-properties
            (kill-line)
            (kill-line))))

      (defun org-roam-insert-note-from-headline ()
        "Create an Org-roam note from the current headline and jump to it.

              Normally, insert the headline’s title using the ’#title:’ file-level property
              and delete the Org-mode headline. However, if the current headline has a
              Org-mode properties drawer already, keep the headline and don’t insert
              ‘#+title:'. Org-roam can extract the title from both kinds of notes, but using
              ‘#+title:’ is a bit cleaner for a short note, which Org-roam encourages."
        (interactive)
        (let ((title (nth 4 (org-heading-components)))
              (has-properties (org-get-property-block)))
          (org-cut-subtree)
          (org-roam-node-find 'other-window title nil)
          (org-paste-subtree)
          (unless has-properties
            (kill-line)
            (while (outline-next-heading)
              (org-promote)))
          (goto-char (point-min))
          (when has-properties
            (kill-line)
            (kill-line))))

#+END_SRC

#+RESULTS:
: org-roam-insert-note-from-headline
***** Org roam ui
#+begin_src emacs-lisp :lexical no
  (use-package org-roam-ui
    :straight
      (:host github :repo "org-roam/org-roam-ui" :branch "main" :files ("*.el" "out"))
      :after org-roam
      :config
      (setq org-roam-ui-sync-theme t
            org-roam-ui-follow t
            org-roam-ui-update-on-save t
            org-roam-ui-open-on-start t))
#+end_src

#+RESULTS:
: t

**** Org readwise
#+begin_src emacs-lisp :lexical no
  (use-package org-readwise
    :quelpa (org-readwise :fetcher github :repo "CountGreven/org-readwise")
    :config
    ;; Ensure auth-source is configured to find your Readwise token
    (setq auth-sources '("~/.authinfo"))
    
    ;; Set the output location for your highlights (buffer or file)
    (setq org-readwise-output-location "~/Org/readwise-highlights.org")
    
    ;; Optionally set the debug level (0 = no debug, 1 = basic debug, 2 = detailed debug)
    (setq org-readwise-debug-level 1))
#+end_src

#+RESULTS:
: t

**** Deft (disabled)
#+begin_src example
  (use-package deft
    :ensure t
    :bind ("<f9>" . deft)
    :demand t
    :init
    (setq deft-directory "~/Org/Notes"
  				deft-text-mode 'org-mode
          deft-extensions '("org" "txt" "md")
          deft-default-extension "org"
          deft-recursive t
          deft-new-file-format "%Y-%m-%dT%H%M"))
#+end_src

#+RESULTS:
: deft

#+begin_src example :lexical no
  (evil-leader/set-key
  	"fn" 'deft-new-file
  	"fl" 'deft)
#+end_src

#+RESULTS:

**** Restclient
Replace Postman with org-mode!

#+begin_src emacs-lisp
  (use-package restclient
    :ensure t)
#+end_src

#+RESULTS:

**** Small packages
***** TOC (disabled)
#+begin_src example 
  (use-package toc-org
    :ensure t
    :config
    (if (require 'toc-org nil t)
        (progn
          (add-hook 'org-mode-hook 'toc-org-mode))
      (warn "toc-org not found")))
#+end_src

***** Org-download
#+begin_src emacs-lisp 
  (use-package org-download
    :ensure t
    :demand t
    :bind (:map org-mode-map
                ("C-x p m"    . org-download-clipboard)
                ("C-x p o"    . org-download-image))
    :config
    (setq-default org-download-image-dir "./assets-org/"))
#+end_src

***** Org-cliplink
#+begin_src emacs-lisp 
  (use-package org-cliplink
    :ensure t
    :demand t
    :config
    (setq org-cliplink-max-length 800)
    (global-set-key (kbd "C-x p i") 'org-cliplink))
#+end_src

***** Org-gtd

#+begin_src emacs-lisp :lexical no
  ;; (evil-leader/set-key
  ;; "de" 'org-gtd-engage
  ;; "dr" 'org-gtd-engage-grouped-by-context
  ;; "dp" 'org-gtd-process-inbox
  ;; "c" 'org-gtd-organize)

  (evil-leader/set-key
  	;; "dc" 'org-gtd-capture
    "dc" (lambda () (interactive) (org-gtd-capture nil "i"))
  	"de" 'org-gtd-engage
  	"dp" 'org-gtd-process-inbox
  	"dn" 'org-gtd-show-all-next
  	"ds" 'org-gtd-review-stuck-projects)
#+end_src
 
#+RESULTS:

#+begin_src emacs-lisp :lexical no
  (use-package org-gtd
    :ensure t
    :straight (org-gtd :type git
                       :host github
                       :repo "trevoke/org-gtd.el")
    :custom
    (org-gtd-directory "~/Org/agenda/GTD/")
    ;; (org-edna-use-inheritance t)
    ;; (org-gtd-update-ack "3.0.0")
  	(org-gtd-areas-of-focus '("PERSONAL" "MERITRANK" "CODING" "EGE"))
    (org-gtd-organize-hooks '(org-gtd-set-area-of-focus org-set-tags-command))
  	(org-gtd-clarify-show-horizons t)
  	(org-gtd-horizons-file "horizons.org")
    :config
    (org-edna-mode)
    :bind (("C-c d c" . (lambda () (interactive) (org-gtd-capture nil "i")))
  				 ("C-c d e" . org-gtd-engage)
  				 ("C-c d r" . org-gtd-engage-grouped-by-context)
  				 ("C-c d p" . org-gtd-process-inbox)
  				 :map org-gtd-clarify-map
  				 ("C-c c" . org-gtd-organize)))
#+end_src

#+RESULTS:
: org-gtd-organize

***** Org-clock-budget
#+begin_src emacs-lisp :lexical no
  (use-package org-clock-budget
      :quelpa (org-clock-budget
          :fetcher github
          :repo "Fuco1/org-clock-budget"
          :branch "master")
  		:ensure t
      :config
      (setq org-clock-budget-daily-budgetable-hours 10)
      (setq org-clock-budget-intervals '(("BUDGET_WEEK" org-clock-budget-interval-this-week))))
#+end_src

#+RESULTS:
: t

***** Org-appear
Toggle visibility of hidden Org mode element parts upon entering and leaving an element
#+begin_src emacs-lisp 
  (use-package org-appear
    :ensure t
    :hook
    (org-mode . org-appear-mode)
    :config
    (setq org-hide-emphasis-markers t
          org-appear-autolinks 'just-brackets))
#+end_src

***** Org-transclusion (disabled)
#+begin_src example 
  (use-package org-transclusion
    :after org
    :ensure t
    :config
    (define-key global-map (kbd "<f12>") #'org-transclusion-add)
    (define-key global-map (kbd "C-c t") #'org-transclusion-mode))
#+end_src

***** Org-timeblock
#+begin_src emacs-lisp 
  (use-package timeblock
    :init
    (unless (package-installed-p 'timeblock)
      (package-vc-install
       '(timeblock
         :vc-backend Git
         :url "https://github.com/ichernyshovvv/timeblock.el"
         :branch "master"))))
#+end_src

#+RESULTS:

#+begin_src emacs-lisp :lexical no
  (use-package org-timeblock
    :straight (org-timeblock :type git
   													 :host github
   													 :repo "ichernyshovvv/org-timeblock")
    :demand t
    :bind
    (:map global-map
   				("C-c s" . org-timeblock))
    :config
    (setq org-now-location '("~/Org/agenda/Calendar.org")
          org-timeblock-inbox-file "/home/berezhnev/Org/agenda/Calendar.org"
          org-timeblock-n-days-view 3))
#+end_src

#+RESULTS:
: org-timeblock

****** Example
#+begin_src emacs-lisp :lexical no

  ;; -*- lexical-binding: t; -*- 

  (require 'org) ;; for `org-read-date'

  (let* ((date (parse-time-string "2024-11-08 00:00"))
         (entries
          (list (list
                 (cons 'start (parse-time-string "2024-11-08 10:00"))
                 (cons 'end (parse-time-string "2024-11-08 11:00"))
                 (cons 'title "Block 1"))
                (list
                 (cons 'start (parse-time-string "2024-11-08 09:30"))
                 (cons 'end (parse-time-string "2024-11-08 11:00"))
                 (cons 'title "Block 2"))
                (list
                 (cons 'start (parse-time-string "2024-11-08 12:00"))
                 (cons 'end (parse-time-string "2024-11-08 17:00"))
                 (cons 'title "Block 4"))
                (list
                 (cons 'start (parse-time-string "2024-11-08"))
                 (cons 'end nil)
                 (cons 'title "All-day Block 3")))))
    (timeblock-insert-column
     entries date 200 350
     :show-date t :show-all-day-entries t
     :scope '(6 . 24)
     :keymap (let ((map timeblock-column-map))
               (keymap-set map "e" #'timeblock-reschedule)
               (keymap-set map "<drag-mouse-1>" #'timeblock-drag-n-drop)
               map)))
   
  (defun timeblock-reschedule ()
    (interactive)
    (when-let* ((svg (get-text-property (point) 'dom))
                (entries (dom-attr svg 'entries))
                (date (encode-time (dom-attr svg 'date)))
                (block-id (dom-attr (timeblock-get-selected svg) 'id))
                (entry (nth (string-to-number block-id) entries)))
      (setf (alist-get 'start entry)
            (decode-time (org-read-date t t nil "Start: " date)))
      (setf (alist-get 'end entry)
            (decode-time (org-read-date t t nil "End: " date)))
      (timeblock-redisplay-column)))

  (defun timeblock-drag-n-drop (event)
    "Draw a line from the start of EVENT to its end."
    (interactive "e")
    (when-let* ((start (posn-object-x-y (event-start event)))
                (end (posn-object-x-y (event-end event)))
                (svg (get-text-property (point) 'dom))
                (entries (dom-attr svg 'entries))
                (block-id
                 (dom-attr
                  (timeblock-block-at-position svg (car start) (cdr start)) 'id))
                (entry (nth (string-to-number block-id) entries))
                (hour (timeblock-hour-at-position svg (cdr end))))
      (let* ((start-ts (alist-get 'start entry))
             (end-ts (alist-get 'end entry))
             (duration (and end-ts (timeblock-time-diff end-ts start-ts)))
             (new-start-ts (timeblock-time-apply start-ts :hour hour :minute 0))
             (new-end-ts (and duration
                              (timeblock-time-inc 'minute duration new-start-ts))))
        (setf (alist-get 'start entry) new-start-ts)
        (setf (alist-get 'end entry) new-end-ts)
        (timeblock-redisplay-column))))

  (cl-defun timeblock-time-apply (time &key second minute hour day month year)
    "Return new timestamp based on TIME with new slot values from keys."
    (declare (indent 1))
    ;; This code is borrowed from `ts-apply' function which is part of ts.el
    ;; project written by Adam Porter
    (let ((time (copy-sequence time)))
      (and second (setf (decoded-time-second time) second))
      (and minute (setf (decoded-time-minute time) minute))
      (and hour (setf (decoded-time-hour time) hour))
      (and day (setf (decoded-time-day time) day))
      (and month (setf (decoded-time-month time) month))
      (and year (setf (decoded-time-year time) year))
      time))

  (defun timeblock-time-diff (a b)
    "Return difference between times A and B in minutes."
    (when-let* ((a (encode-time a))
                (b (encode-time b)))
      (/ (time-convert (time-subtract a b) 'integer) 60)))

  (defun timeblock-time-inc (slot value time)
    "Return a new time object based on TIME with its SLOT incremented by VALUE.

  SLOT should be specified as a plain symbol, not a keyword."
    (let ((time (copy-sequence time)))
      (decoded-time-add time (make-decoded-time (intern (format ":%s" slot)) value))) )
#+end_src

#+RESULTS:
: timeblock-time-inc

*** Lisp
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :ensure t
  :config
  (add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode))
#+END_SRC

Select a code block in a visual mode and press ~TAB~ to re-indent it

#+BEGIN_SRC emacs-lisp
(general-vmap
  :keymaps 'lisp-interaction-mode-map
  "<tab>" #'indent-region)
#+END_SRC

When submitting packages to MELPA, they need to be checked using ~package-lint~

See https://github.com/purcell/package-lint

#+BEGIN_SRC emacs-lisp
(use-package package-lint
  :ensure t)
#+END_SRC

*** JSON

#+BEGIN_SRC emacs-lisp
(use-package json-mode
  :ensure t)
#+END_SRC

*** Protobuf
#+begin_src emacs-lisp :lexical no
  (use-package protobuf-mode
  	:ensure t)
#+end_src

#+RESULTS:

*** TypeScript
Add support of ~.ts~ and ~.tsx~ files
#+BEGIN_SRC emacs-lisp
(use-package typescript-mode
  :ensure t
  :mode (("\\.ts\\'" . typescript-mode)
         ("\\.tsx\\'" . typescript-mode))
  :config
  ;; we choose this instead of tsx-mode so that eglot can automatically figure out language for server
  ;; see https://github.com/joaotavora/eglot/issues/624 and https://github.com/joaotavora/eglot#handling-quirky-servers
  (define-derived-mode typescriptreact-mode typescript-mode
    "TypeScript TSX"))
#+END_SRC

*** Rust
#+BEGIN_SRC emacs-lisp
  (use-package rustic
    :ensure t
    :bind (:map rustic-mode-map
                ("M-j" . lsp-ui-imenu)
                ("M-?" . lsp-find-references)
                ("C-c C-c l" . flycheck-list-errors)
                ("C-c C-c a" . lsp-execute-code-action)
                ("C-c C-c r" . lsp-rename)
                ("C-c C-c q" . lsp-workspace-restart)
                ("C-c C-c Q" . lsp-workspace-shutdown)
                ("C-c C-c s" . lsp-rust-analyzer-status))
    :config
    ;;(setq rustic-format-on-save t)
    ;;(add-hook 'rustic-mode-hook 'rk/rustic-mode-hook)

    (defun rk/rustic-mode-hook ()
      ;; so that run C-c C-c C-r works without having to confirm, but don't try to
      ;; save rust buffers that are not file visiting. Once
      ;; https://github.com/brotzeit/rustic/issues/253 has been resolved this should
      ;; no longer be necessary.
      (when buffer-file-name
        (setq-local buffer-save-without-query t))
      (add-hook 'before-save-hook 'lsp-format-buffer nil t))

    (use-package rust-playground
      :ensure t)

    ;; (use-package cargo
    ;;   :ensure t
    ;;   :if (executable-find "cargo")
    ;;   :after rust-mode
    ;;   :bind (:map cargo-minor-mode-map
    ;;               ("C-c C-t" . cargo-process-test)
    ;;               ("C-c C-b" . cargo-process-build)
    ;;               ("C-c C-c" . cargo-process-run))
    ;;   :config
    ;;   (add-hook 'rust-mode-hook 'cargo-minor-mode))
    )
#+END_SRC

#+RESULTS:
: lsp-rust-analyzer-status

*** Go
#+begin_src emacs-lisp :lexical no
  (use-package go-mode
    :straight t
  	:ensure t
    :mode ("\\.go\\'" . go-mode)
    :config
    (defun my-go-mode-hook ()
      (setq tab-width 2)
      (setq gofmt-command "goimports")
      (set (make-local-variable 'company-backends) '(company-go))
      (company-mode))
    (add-hook 'go-mode-hook 'my-go-mode-hook))

  (use-package company-go
    :after (company go-mode)
  	:ensure t
    :straight t)

  (use-package go-errcheck
    :after go-mode
  	:ensure t
    :straight t)
#+end_src

#+RESULTS:

*** GraphQL (disabled)
#+begin_src example :lexical no
    (use-package graphql-mode
  		:ensure t)
#+end_src

#+RESULTS:

*** Yaml (disabled)
#+begin_src example :lexical no
  (use-package yaml-mode
  	:ensure t)
#+end_src

** LSP

See https://emacs-lsp.github.io/lsp-mode/

#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :ensure t
    :commands (lsp lsp-deferred)
    :bind (:map lsp-mode-map
                ("C-c f" . lsp-format-buffer))
    :hook (;;(go-mode         . lsp-deferred)
           (rust-mode       . lsp-deferred)
           ;; (lisp            . lsp)
           (python-mode     . lsp-deferred)
           (c-mode          . lsp-deferred)
           ;; (c++-mode        . lsp-deferred)
           (js-mode         . lsp-deferred)
           ;; (solidity-mode   . lsp-deferred)
           (typescript-mode . lsp-deferred)
           (lsp-mode        . lsp-enable-which-key-integration))
    :init
    (setq lsp-keymap-prefix "C-c l")
    :custom
    ;; what to use when checking on-save. "check" is default, I prefer clippy
    (lsp-rust-analyzer-cargo-watch-command "clippy")
    (lsp-eldoc-render-all t)
    (lsp-idle-delay 0) ;; BEFORE: 0.2
    ;; enable / disable the hints as you prefer:
    (lsp-inlay-hint-enable t)
    ;; These are optional configurations. See https://emacs-lsp.github.io/lsp-mode/page/lsp-rust-analyzer/#lsp-rust-analyzer-display-chaining-hints for a full list
    (lsp-rust-analyzer-display-lifetime-elision-hints-enable "skip_trivial")
    (lsp-rust-analyzer-display-chaining-hints t)
    (lsp-rust-analyzer-display-lifetime-elision-hints-use-parameter-names nil)
    (lsp-rust-analyzer-display-closure-return-type-hints t)
    (lsp-rust-analyzer-display-parameter-hints t)
    ;; (lsp-rust-analyzer-display-reborrow-hints t)

    :config
    (setq lsp-headerline-breadcrumb-enable nil)
  	(setq lsp-signature-render-documentation nil)
  	(with-eval-after-load 'lsp-mode
  		(set-face-attribute 'lsp-face-highlight-read nil :underline nil))
  	(setq lsp-enable-snippet t) ;; nil
  	(setq lsp-lens-enable t) ;; nil
  	(setq lsp-diagnostic-provider :none))
#+END_SRC

#+RESULTS:
: lsp-format-buffer

See https://github.com/emacs-lsp/helm-lsp

#+BEGIN_SRC emacs-lisp
(use-package helm-lsp
  :ensure t)
#+END_SRC

*** LSP UI
#+BEGIN_SRC emacs-lisp
  (use-package lsp-ui
    :ensure t
    :hook (lsp-mode . lsp-ui-mode)
    :commands lsp-ui-mode
    :config
    (setq
     lsp-inlay-hints-mode t
     lsp-ui-doc-enable t
     lsp-ui-doc-max-height 8
     lsp-ui-doc-max-width 130         ; 150 (default) is too wide
     lsp-ui-doc-delay 0.1           ; 0.2 (default) is too naggy
     lsp-ui-doc-show-with-mouse t  ; don't disappear on mouseover
     ;; lsp-ui-doc-show-with-cursor t
     lsp-ui-doc-border (face-foreground 'default)
     lsp-ui-doc-position 'at-point
     lsp-ui-doc-include-signature t
     lsp-ui-doc-header t))

#+END_SRC

#+RESULTS:
| lsp-ui-mode | lsp-enable-which-key-integration |

*** Docker

Install syntax highlighting for dockerfiles

#+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode
  :ensure t)
#+END_SRC

** Formatting
#+BEGIN_SRC emacs-lisp
(use-package format-all
  :ensure t
  :preface
  (defun ian/format-code ()
    "Auto-format whole buffer."
    (interactive)
    (if (derived-mode-p 'prolog-mode)
        (prolog-indent-buffer)
      (format-all-buffer)))
  :config
  (global-set-key (kbd "M-F") 'ian/format-code)
  (global-set-key (kbd "C-c C-f") 'format-all-buffer)
  (add-hook 'prog-mode-hook 'format-all-ensure-formatter))
#+END_SRC

#+RESULTS:
: t

#+begin_src emacs-lisp :lexical no
  (setq display-line-numbers 'relative)
#+end_src

#+RESULTS:
: relative

** DirEnv
#+begin_src emacs-lisp :lexical no
  (use-package direnv
  	:ensure t
  	:config
  	(direnv-mode))
#+end_src

#+RESULTS:
: t

** GPTel
:PROPERTIES:
:ID:       7820f2fc-8be2-496c-8d03-b76ba53254b1
:END:

#+begin_src emacs-lisp
  (use-package gptel
    ;;:load-path "~/.emacs.d/gptel/"
    :ensure t
    :init
    (setq gptel-api-key (getenv "AIML_API"))
    (setq gptel-max-tokens 8024)
    :config
    (setq gptel-model 'gpt-4o
          gptel-backend
          (gptel-make-openai "AIMLAPI"
            :host "api.aimlapi.com"
            :endpoint "/chat/completions"
            :stream t
            :key gptel-api-key
            :models '(gpt-4o
                      gpt-4o-2024-08-06
                      gpt-4-turbo
                      chatgpt-4o-latest)))
    :bind (("M-s M-d" . gptel-context-add)
           ("M-s M-f" . gptel-add-file)
           ("M-s M-a" . gptel-menu)
           ("M-s M-r" . gptel--regenerate)
           ("M-s M-e" . gptel-rewrite)
           ("M-s M-s" . gptel)))
#+end_src

#+RESULTS:
: gptel

** Whisper.el
#+begin_src emacs-lisp :lexical no
  (use-package whisper
    :load-path "~/.emacs.d/lisp/whisper.el"
    :bind ("M-s M-t" . whisper-run)
    :config
    (setq whisper-install-directory "/tmp/"
          whisper-model "base"
          ;; whisper-model "base"
          whisper-language "ru"
          whisper-translate nil
          whisper-use-threads (/ (num-processors) 2)
          whisper-enable-speed-up nil
          whisper-recording-timeout 300))
#+end_src

#+RESULTS:
: whisper-run
